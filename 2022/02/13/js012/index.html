

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>JavaScript学习笔记（12）：DOM基础 - 大森的博客</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="DOM节点任何HTML或XML文档都可以用DOM表示为...">
  <meta name="author" content="Dasen Sun">
  <link rel="icon" href="/images/icons/logo-16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/logo-32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/logo-180.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/logo-144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_r673sha78lq.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '[object Object]'
      },
      donate: {
        enable: true,
        alipay: '/images/qrcode/alipay.jpg',
        wechat: '/images/qrcode/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '人生如逆旅，我亦是行人。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: '/images/qrcode/qrcode.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: false,
        path: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
    </div>
    <div class="center">JavaScript学习笔记（12）：DOM基础</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>　
      </li><li class="menu-item">
        <a href="/categories/cpp/ " class="underline "> C++</a>　
      </li><li class="menu-item">
        <a href="/categories/frontend/ " class="underline "> HTML/CSS</a>　
      </li><li class="menu-item">
        <a href="/categories/js/ " class="underline "> JavaScript</a>　
      </li><li class="menu-item">
        <a href="/categories/notes/ " class="underline "> 课程笔记</a>　
      </li><li class="menu-item">
        <a href="/categories/tools/ " class="underline "> 工具</a>　
      </li><li class="menu-item">
        <a href="/categories/other/ " class="underline "> 其他</a>　
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>　
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  孙大森 - 2021</p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/post/js.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">JavaScript学习笔记（12）：DOM基础</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>February 13, 2022</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>16486</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h1 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h1><p>任何HTML或XML文档都可以<strong>用DOM表示为一个由节点构成的层级结构</strong>。</p>
<p>节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系，这些关系构成了层级，<strong>让标记可以表示为一个以特定节点为根的树形结构</strong>。</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>document节点表示每个文档的<strong>根节点</strong>，<strong>根节点的唯一子节点是文档元素</strong>。</p>
<p>文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内。</p>
<p><strong>每个文档只能有一个文档元素</strong>，在HTML页面中，文档元素始终是<code>&lt;html&gt;</code>元素；在XML文档中，则没有这样预定义的元素，任何元素都可能成为文档元素。</p>
<p>HTML中的每段标记都可以表示为这个树形结构中的一个节点，DOM中总共有12种节点类型。</p>
<p>在JavaScript中，所有节点类型都继承Node类型，因此所有类型都共享相同的基本属性和方法，以下即为Node类型的共有的属性。如果没有强调，下列属性都是只读的。</p>
<h3 id="nodeType属性"><a href="#nodeType属性" class="headerlink" title="nodeType属性"></a>nodeType属性</h3><p>每个节点都有nodeType属性，表示该节点的类型。节点类型由定义在Node类型上的12个数值常量表示：</p>
<ul>
<li><code>Node.ELEMENT_NODE</code>（1）：元素节点。</li>
<li><code>Node.ATTRIBUTE_NODE</code>（2）：元素的耦合属性。已弃用。</li>
<li><code>Node.TEXT_NODE</code>（3）：元素或者属性中的文字。</li>
<li><code>Node.CDATA_SECTION_NODE</code>（4）：CDATASection。</li>
<li><code>Node.ENTITY_REFERENCE_NODE</code>（5）：XML 实体引用节点。已弃用。</li>
<li><code>Node.ENTITY_NODE</code>（6）：XML <code>&lt;!ENTITY ...&gt;</code>  节点。已弃用。</li>
<li><code>Node.PROCESSING_INSTRUCTION_NODE</code>（7）：用于XML文档的ProcessingInstruction。</li>
<li><code>Node.COMMENT_NODE</code>（8）：注释节点。</li>
<li><code>Node.DOCUMENT_NODE</code>（9）：Document节点。</li>
<li><code>Node.DOCUMENT_TYPE_NODE</code>（10）：描述文档类型的DocumentType节点。</li>
<li><code>Node.DOCUMENT_FRAGMENT_NODE</code>（11）：DocumentFragment节点。</li>
<li><code>Node.NOTATION_NODE</code>（12）：XML <code>&lt;!NOTATION ...&gt;</code> 节点。已弃用。</li>
</ul>
<p>节点类型可通过与这些常量比较来确定，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (someNode.nodeType == Node.ELEMENT_NODE) &#123;<br>    alert(<span class="hljs-string">&quot;Node is an element.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>比较了<code>someNode.nodeType</code>与<code>Node.ELEMENT_NODE</code>，如果两者相等，则意味着someNode是一个元素节点。</p>
<p>浏览器并不一定支持所有节点类型，开发者最常用到的是<strong>元素节点</strong>和<strong>文本节点</strong>，因此我们着重强调元素节点和文本节点所拥有的属性和方法，并非所有节点都有这些属性和方法。</p>
<h3 id="nodeName属性"><a href="#nodeName属性" class="headerlink" title="nodeName属性"></a>nodeName属性</h3><p>返回一个存储了当前节点的节点名称的字符串。</p>
<p>对于元素节点来说，该属性为<strong>标签名</strong>，且<strong>在XML中为区分大小写的标签名，在HTML中为全大写</strong>。</p>
<h3 id="nodeValue属性"><a href="#nodeValue属性" class="headerlink" title="nodeValue属性"></a>nodeValue属性</h3><p>nodeValue是<strong>可写的</strong>，通过它可以改变其值。</p>
<p>文本节点、注释节点和CDATA节点来说的nodeValue为该节点的<strong>文本内容</strong>。</p>
<p>属性节点的nodeValue为该属性的<strong>属性值</strong>。</p>
<p>ProcessingInstruction节点的nodeValue为<strong>整个标签的文本内容</strong>。</p>
<p>其余节点的nodeValue都为<strong>null</strong>。</p>
<h3 id="childNodes属性"><a href="#childNodes属性" class="headerlink" title="childNodes属性"></a>childNodes属性</h3><p>节点关系即文档树中节点之间的关系，文档中所有节点都与其他节点有关系。</p>
<p>每个节点都有一个childNodes属性，其中包含一个<strong>NodeList的实例</strong>。NodeList是一个类数组对象，用于<strong>存储可以按位置存取的有序节点</strong>。</p>
<p>但是注意！<strong>NodeList对象只在此处为动态的</strong>，即其内容会随着页面DOM结构的变化实时更新，但在其他情况下（如<code>document.querySelectorAll()</code>方法返回的），NodeList对象都是静态的，只是一个当时的快照，不会随着文档DOM结构变化而更新。</p>
<h3 id="parentNode属性"><a href="#parentNode属性" class="headerlink" title="parentNode属性"></a>parentNode属性</h3><p>每个节点都有一个parentNode属性，指向其DOM树中的父元素。childNodes中的所有节点都有同一个父元素，因此它们的parentNode属性都指向同一个节点。</p>
<h3 id="previousSibling属性和nextSibling属性"><a href="#previousSibling属性和nextSibling属性" class="headerlink" title="previousSibling属性和nextSibling属性"></a>previousSibling属性和nextSibling属性</h3><p>childNodes列表中的每个节点都是同一列表中其他节点的同胞节点，使用previousSibling和nextSibling可以在这个列表的节点间导航。<br>这个列表中第一个节点的previousSibling属性是null，最后一个节点的nextSibling属性也是null。</p>
<h3 id="firstChild属性和lastChild属性"><a href="#firstChild属性和lastChild属性" class="headerlink" title="firstChild属性和lastChild属性"></a>firstChild属性和lastChild属性</h3><p>firstChild和lastChild分别指向节点的childNodes中的第一个和最后一个子节点。</p>
<h3 id="ownerDocument属性"><a href="#ownerDocument属性" class="headerlink" title="ownerDocument属性"></a>ownerDocument属性</h3><p>ownerDocument属性是每个节点都有的，指向代表整个文档的文档节点的指针。</p>
<h3 id="hasChildNodes方法"><a href="#hasChildNodes方法" class="headerlink" title="hasChildNodes方法"></a>hasChildNodes方法</h3><p>返回元素是否有孩子，<code>hasChildNodes()</code>方法如果返回true则说明节点有子节点。相比查询childNodes的length属性，这个方法更方便。</p>
<h3 id="appendChild方法"><a href="#appendChild方法" class="headerlink" title="appendChild方法"></a>appendChild方法</h3><p><code>appendChild()</code>方法用于在childNodes列表末尾添加节点，同时更新所有有关的节点关系。</p>
<h3 id="insertBefore方法"><a href="#insertBefore方法" class="headerlink" title="insertBefore方法"></a>insertBefore方法</h3><p><code>insertBefore()</code>方法接收两个参数：要插入的节点和参照节点。这样可以把节点插入到childNodes列表中<strong>指定子节点前面</strong>。如果它第二个参数为null，那么它和<code>appendChild()</code>方法效果一样。</p>
<h3 id="replaceChild方法"><a href="#replaceChild方法" class="headerlink" title="replaceChild方法"></a>replaceChild方法</h3><p><code>replaceChild()</code>方法接收两个参数：新的节点和要被替换的节点。这样可以用新节点替换掉childNodes列表中的指定节点。要替换的节点会被返回并从文档树中完全移除。</p>
<h3 id="removeChild方法"><a href="#removeChild方法" class="headerlink" title="removeChild方法"></a>removeChild方法</h3><p><code>removeChild()</code>方法接收一个参数，即要移除的节点，返回值是被移除的节点。这样可以从节点的孩子中删除掉一个节点。</p>
<h3 id="cloneNode方法"><a href="#cloneNode方法" class="headerlink" title="cloneNode方法"></a>cloneNode方法</h3><p><code>cloneNode()</code>方法会返回与调用它的节点一模一样的节点。</p>
<p><code>cloneNode()</code>方法接收一个布尔值参数，表示是否深复制。在传入true参数时，会进行深复制，即复制节点及其整个子DOM树。如果传入false，则只会复制调用该方法的节点。</p>
<p>复制返回的节点属于文档所有，但尚未指定父节点，所以可称为<strong>孤儿节点</strong>。之后可将其插入文档结构中。</p>
<h3 id="normalize方法"><a href="#normalize方法" class="headerlink" title="normalize方法"></a>normalize方法</h3><p>在节点上调用<code>normalize()</code>方法会检测这个节点的所有后代，如果发现空文本节点，则将其删除；同时将多个连续的文本节点合并为一个文本节点。</p>
<h2 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h2><p>在浏览器中，文档对象document是HTMLDocument的实例，表示整个HTML页，而HTMLDocument又继承自Document面。</p>
<p>Document类型的节点有以下特征：</p>
<ul>
<li>nodeType值为9。</li>
<li>nodeName值为<code>&quot;#document&quot;</code>。</li>
<li>nodeValue值为null。</li>
<li>parentNode值为null。</li>
<li>ownerDocument值为null。</li>
<li>子节点可以是DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或Comment类型。</li>
</ul>
<p>理论上讲，出现在文档中的内容都应该是document的子节点，但是出现在<code>&lt;html&gt;</code>元素之外的注释可能被忽略或部分忽略。</p>
<h3 id="documentElement属性"><a href="#documentElement属性" class="headerlink" title="documentElement属性"></a>documentElement属性</h3><p><code>document.childNodes</code>中始终有<code>&lt;html&gt;</code>元素，但使用<code>document.documentElement</code>属性可以更快更直接地访问该元素，该属性始终指向HTML页面中的<code>&lt;html&gt;</code>元素</p>
<h3 id="body属性"><a href="#body属性" class="headerlink" title="body属性"></a>body属性</h3><p>document对象还有一个body属性，直接指向<code>&lt;body&gt;</code>元素，因为这个元素是开发者使用最多的元素。</p>
<h3 id="doctype属性"><a href="#doctype属性" class="headerlink" title="doctype属性"></a>doctype属性</h3><p>DocumentType也是Document类型可能的子节点。</p>
<p><code>&lt;! doctype&gt;</code>标签是文档中独立的部分，其可以通过<code>document.doctype</code>来访问。</p>
<h3 id="title属性"><a href="#title属性" class="headerlink" title="title属性"></a>title属性</h3><p>通过这个属性可以读写<strong>页面的标题</strong>，修改后的标题也会反映在浏览器标题栏上。</p>
<p>但注意这个属性和<code>&lt;title&gt;</code>元素是无关的。</p>
<h3 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h3><p>document对象包含三个与链接有关的属性，分别是URL属性、domain属性和referrer属性。</p>
<ul>
<li>URL属性：包含当前页面的完整URL（地址栏中的URL）。</li>
<li>domain属性：包含页面的域名。</li>
<li>referrer属性：包含链接到当前页面的那个页面的URL。如果当前页面没有来源，则referrer属性包含空字符串。</li>
</ul>
<p>所有这些信息都可以在请求的HTTP头部信息中获取，只是在JavaScript中通过这几个属性暴露出来而已。</p>
<p>例如：<code>document.URL</code>是<code>http://www.wrox.com/WileyCDA/</code>，则<code>document.domain</code>就是<code>www.wrox.com</code>。</p>
<p>在这些属性中，只有domain属性是可以设置的。出于安全考虑，<strong>给domain属性设置的值是有限制的</strong>，不能给这个属性设置与当前域名毫不相干的值。因此这个属性的用处也非常有限，也仅仅是能够在个别场景下实现跨域访问。</p>
<h3 id="获取元素的方法"><a href="#获取元素的方法" class="headerlink" title="获取元素的方法"></a>获取元素的方法</h3><p>document对象上的以下方法可以用来获取页面上的元素：</p>
<ul>
<li><code>getElementById()</code>方法：根据元素ID获取元素DOM。只返回一个元素，没有找到返回null。多个元素ID相同则返回第一个。</li>
<li><code>getElementsByTagName()</code>方法：根据标签名获取元素。返回一个HTMLCollection对象。可接受通配符<code>&quot;*&quot;</code>作为参数，这将会获取所有标签。虽然规范要求其区分大小写，但实际上在HTML中它是不区分大小写的，在XML中区分大小写。</li>
<li><code>getElementsByName()</code>方法：根据name属性获取元素。返回一个HTMLCollection对象。</li>
<li><code>getElementsByClassName()</code>方法：根据类名获取元素。返回一个HTMLCollection对象。（HTML5扩展方法）</li>
</ul>
<p>这些方法中返回的是HTMLCollection对象，它和NodeList对象很像，区别是<strong>HTMLCollection对象始终是动态的，是一个实时的列表</strong>。</p>
<p>HTMLCollection对象还有两个额外的方法：</p>
<ul>
<li><code>item()</code>方法：可通过下标来访问HTMLCollection中的元素。</li>
<li><code>namedItem()</code>方法：可通过标签的name属性取得HTMLCollection对象中某一项的引用。</li>
</ul>
<p>而同时，还可以通过中括号的方式访问其中的项目，如果中括号中的是字符串，那么像访问字典一样地也可以根据name访问到某一项，就像调用了<code>namedItem()</code>方法一样；如果提供的是索引，那么就像访问数组一样地访问其中的元素，就像调用了<code>item()</code>方法一样。</p>
<p>因此<strong>HTMLCollection对象既像数组又像字典</strong>。</p>
<h3 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h3><p>document对象上还暴露了几个特殊集合，这些集合也都是HTMLCollection的实例，它们是访问文档中公共部分的快捷方式：</p>
<ul>
<li><code>document.anchors</code>：包含文档中所有带name属性的<code>&lt;a&gt;</code>元素。</li>
<li><code>document.applets</code>：包含文档中所有<code>&lt;applet&gt;</code>元素（<code>&lt;applet&gt;</code>元素已经不建议使用，因此这个集合已经废弃）。</li>
<li><code>document.forms</code>：包含文档中所有<code>&lt;form&gt;</code>元素。</li>
<li><code>document.images</code>：包含文档中所有<code>&lt;img&gt;</code>元素。</li>
<li><code>document.links</code>：包含文档中所有带href属性的<code>&lt;a&gt;</code>元素。</li>
</ul>
<h3 id="DOM兼容性检测"><a href="#DOM兼容性检测" class="headerlink" title="DOM兼容性检测"></a>DOM兼容性检测</h3><p>由于DOM有多个Level和多个部分，因此确定浏览器实现了DOM的哪些部分是很必要的。</p>
<p><code>document.implementation</code>属性是一个对象，其中提供了与浏览器DOM实现相关的信息和能力。这个对象上只有一个方法，即<code>hasFeature()</code>。这个方法接收两个参数：特性名称和DOM版本。如果浏览器支持指定的特性和版本，则<code>hasFeature()</code>方法返回true。</p>
<p>但要注意：由于实现不一致，因此<code>hasFeature()</code>的返回值并不可靠。目前这个方法<strong>已经被废弃</strong>，不再建议使用。为了向后兼容，目前主流浏览器仍然支持这个方法，但无论检测什么都一律返回true。</p>
<h3 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h3><p>document对象有一个古老的能力，即向网页输出流中写入内容。这个能力对应4个方法：<code>write()</code>、<code>writeln()</code>、<code>open()</code>和<code>close()</code>。</p>
<p>其中，<code>write()</code>和<code>writeln()</code>方法都接收一个字符串参数，可以将这个字符串写入网页中。<code>write()</code>简单地写入文本，而<code>writeln()</code>还会在字符串末尾追加一个换行符（<code>\n</code>）。</p>
<p>在页面渲染期间通过<code>document.write()</code>可以向文档中输出内容，如果在页面加载完之后再调用<code>document.write()</code>，则输出的内容会重写整个页面。</p>
<p><code>open()</code>和<code>close()</code>方法分别用于打开和关闭网页输出流。在调用<code>write()</code>和<code>writeln()</code>时，这两个方法都不是必需的。</p>
<p>严格的XHTML文档不支持文档写入。因此对于内容类型为<code>application/xml+xhtml</code>的页面，这些方法不起作用。</p>
<h2 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h2><p>Element表示<strong>XML或HTML元素</strong>，对外暴露出访问元素标签名、子节点和属性的能力。Element类型的节点具有以下特征：</p>
<ul>
<li>nodeType的值等于1。</li>
<li>nodeName值为元素的标签名。</li>
<li>nodeValue值为null。</li>
<li>parentNode值为Document或Element对象。</li>
<li>子节点可以是Element、Text、Comment、ProcessingInstruction、CDATASection、EntityReference类型。</li>
</ul>
<p>可以通过nodeName或tagName属性来获取<strong>元素的标签名</strong>（在HTML中全大写）。</p>
<p>如果不确定脚本是在HTML文档还是XML文档中运行，最好将标签名转换为小写形式，以便于比较。</p>
<h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><p>HTML元素都通过HTMLElement类型表示，HTMLElement直接继承Element并增加了一些属性，它们是所有HTML元素上都有的标准属性：</p>
<ul>
<li>id：元素在文档中的唯一标识符。</li>
<li>title：包含元素的额外信息，通常以提示条形式展示。</li>
<li>lang：元素内容的语言代码（很少用）。</li>
<li>dir：语言的书写方向（<code>&quot;ltr&quot;</code>表示从左到右，<code>&quot;rtl&quot;</code>表示从右到左，同样很少用）。</li>
<li>className：相当于class属性，用于指定元素的CSS类（因为class是ECMAScript关键字，所以不能直接用这个名字）。</li>
</ul>
<p>所有这些<strong>都可以用来获取对应的属性值，也可以用来修改相应的值</strong>。</p>
<h3 id="获取元素属性"><a href="#获取元素属性" class="headerlink" title="获取元素属性"></a>获取元素属性</h3><p>与属性相关的DOM方法主要有3个：</p>
<ul>
<li><code>getAttribute()</code>方法：获取属性的值指定属性不存在则返回null。</li>
<li><code>setAttribute()</code>方法：设置属性值。参数为属性名和要设置的值。通过该方法设置的属性名都会变为规范的小写形式。</li>
<li><code>removeAttribute()</code>方法：移除属性。</li>
</ul>
<p>注意：属性名不区分大小写。且根据HTML5规范的要求，自定义属性名应该前缀<code>data-</code>以方便验证。</p>
<p>属性可以通过<code>getAttribute()</code>方法访问，也可通过DOM对象访问，大多情况下两种方式获得的值是一样的，只有两个属性例外：</p>
<ul>
<li>style属性：在使用<code>getAttribute()</code>访问style属性时返回的是CSS字符串；在通过DOM对象的属性访问时，style属性返回的是一个CSSStyleDeclaration对象。</li>
<li>事件处理程序（或者事件属性）：如果使用<code>getAttribute()</code>访问事件属性，则返回的是字符串形式的源代码。而通过DOM对象的属性访问事件属性时返回的则是一个JavaScript函数（未指定该属性则返回null）。</li>
</ul>
<p>同样地，设置属性也可以通过<code>getAttribute()</code>方法或DOM对象。但是<strong>直接在DOM对象上添加的自定义属性并不会自动成为标签的属性</strong>，通过<code>getAttribute()</code>方法是获取不到的。</p>
<h3 id="attributes属性"><a href="#attributes属性" class="headerlink" title="attributes属性"></a>attributes属性</h3><p>Element类型是唯一使用attributes属性的DOM节点类型。</p>
<p>Element对象的attributes属性包含一个NamedNodeMap实例，也是一个“实时”的集合。元素的每个属性都表示为一个Attr节点，并保存在这个NamedNodeMap对象中。</p>
<p>NamedNodeMap对象包含下列方法：</p>
<ul>
<li><code>getNamedItem(name)</code>：返回nodeName属性等于name的节点；</li>
<li><code>removeNamedItem(name)</code>：删除nodeName属性等于name的节点；</li>
<li><code>setNamedItem(node)</code>：向列表中添加node节点，以其nodeName为索引；</li>
<li><code>item(pos)</code>：返回索引位置pos处的节点。</li>
</ul>
<p>attributes属性中的每个节点的nodeName是对应属性的名字，nodeValue是属性的值。每个节点都是nodeType的值为2的Node节点。</p>
<p>attributes属性最有用的场景是需要迭代元素上所有属性的时候。</p>
<h3 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h3><p>使用<code>document.createElement()</code>方法创建新元素。这个方法接收一个参数，即要创建元素的标签名。</p>
<p>使用<code>createElement()</code>方法创建新元素的同时也会将其ownerDocument属性设置为document。此时，可以再为其添加属性、添加更多子元素。</p>
<p>要把创建的元素添加到文档树，可以使用<code>appendChild()</code>、<code>insertBefore()</code>或<code>replaceChild()</code>等方法。</p>
<p>某些元素可以使用new关键字来创建，如Image、Option等。</p>
<h2 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h2><p>Text节点即文档中的文本节点，有以下特征：</p>
<ul>
<li>nodeType的值等于3。</li>
<li>nodeName值为”#text”。</li>
<li>nodeValue值为节点中包含的文本。</li>
<li>parentNode值为Element对象。</li>
<li>不支持子节点。</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>其特殊的属性主要也就是data属性，它和nodeValue属性是一样的，都表示文本的值，修改nodeValue或data的值，也会在另一个属性反映出来。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>文本节点主要有以下方法：</p>
<ul>
<li><code>appendData(text)</code>：向节点末尾添加文本text；</li>
<li><code>deleteData(offset, count)</code>：从位置offset开始删除count个字符；</li>
<li><code>insertData(offset, text)</code>：在位置offset插入text；</li>
<li><code>replaceData(offset, count, text)</code>：用text替换从位置offset到offset+count的文本；</li>
<li><code>splitText(offset)</code>：在位置offset将当前文本节点拆分为两个文本节点；</li>
<li><code>substringData(offset, count)</code>：提取从位置offset到offset+count的文本。</li>
</ul>
<p>要想创建新的文本节点，可以使用<code>document.createTextNode()</code>方法。</p>
<p>前文介绍了<code>normalize()</code>方法，而<code>splitText()</code>方法则是与其相反的方法。</p>
<h2 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h2><p>注释节点的类型，该类型有以下特征：</p>
<ul>
<li>nodeType的值等于8。</li>
<li>nodeName值为<code>&quot;#comment&quot;</code>。</li>
<li>nodeValue值为注释的内容。</li>
<li>parentNode值为Document或Element对象。</li>
<li>不支持子节点。</li>
</ul>
<p>与Text类型相似，注释的实际内容可以通过nodeValue或data属性获得。</p>
<p>同样可以使用<code>document.createComment()</code>方法创建注释节点，参数为注释内容字符串。</p>
<h2 id="CDATASection类型"><a href="#CDATASection类型" class="headerlink" title="CDATASection类型"></a>CDATASection类型</h2><p>CDATASection类型表示XML中特有的CDATA区块。CDATASection类型继承Text类型，因此拥有所有Text节点的方法。CDATASection类型的节点具有以下特征：</p>
<ul>
<li>nodeType的值等于4。</li>
<li>nodeName值为<code>&quot;#cdata-section&quot;</code>。</li>
<li>nodeValue值为CDATA区块的内容。</li>
<li>parentNode值为Document或Element对象。</li>
<li>不支持子节点。</li>
</ul>
<p>CDATA区块只在XML文档中有效，因此某些浏览器比较陈旧的版本会错误地将CDATA区块解析为Comment或Element。</p>
<p>在XML文档中，可以使用<code>document.createCDataSection()</code>并传入节点内容来创建CDATA区块。</p>
<h2 id="DocumentType类型"><a href="#DocumentType类型" class="headerlink" title="DocumentType类型"></a>DocumentType类型</h2><p>DocumentType类型的节点包含文档的文档类型（doctype）信息，具有以下特征：</p>
<ul>
<li>nodeType的值等于10。</li>
<li>nodeName值为文档类型的名称。</li>
<li>nodeValue值为null。</li>
<li>parentNode值为Document对象。</li>
<li>不支持子节点。</li>
</ul>
<p>DocumentType对象在DOM Level 1中不支持动态创建，只能在解析文档代码时创建。</p>
<p>对于支持这个类型的浏览器，DocumentType对象保存在<code>document.doctype</code>属性中。</p>
<p>DOM Level 1规定了DocumentType对象的3个属性：</p>
<ul>
<li>name：文档类型的名称。</li>
<li>entities：这个文档类型描述的实体的NamedNodeMap。</li>
<li>notations：这个文档类型描述的表示法的NamedNodeMap。</li>
</ul>
<p>因为浏览器中的文档通常是HTML或XHTML文档类型，所以entities和notations列表为空。无论如何都只有name属性是有用的。</p>
<p>name属性包含文档类型的名称，即紧跟在<code>&lt;! DOCTYPE</code>后面的那串文本。比如下面的HTML 4.01严格文档类型：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;! DOCTYPE HTML PUBLIC &quot;-// W3C// DTD HTML 4.01// EN&quot;<br>&quot;http:// www.w3.org/TR/html4/strict.dtd&quot;&gt;<br></code></pre></td></tr></table></figure>

<p>对于这个文档类型，name属性的值是<code>&quot;html&quot;</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">alert(<span class="hljs-built_in">document</span>.doctype.name); <span class="hljs-comment">// &quot;html&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h2><p>在所有节点类型中，DocumentFragment类型是唯一一个在标记中没有对应表示的类型。DOM将文档片段定义为“轻量级”文档，能够包含和操作节点，却没有完整文档那样额外的消耗。DocumentFragment节点具有以下特征：</p>
<ul>
<li>nodeType的值等于11。</li>
<li>nodeName值为<code>&quot;#document-fragment&quot;</code>。</li>
<li>nodeValue值为null。</li>
<li>parentNode值为null。</li>
<li>子节点可以是Element、ProcessingInstruction、Comment、Text、CDATASection或EntityReference。</li>
</ul>
<p>不能直接把文档片段添加到文档。相反，文档片段的作用是充当其他要被添加到文档的节点的仓库。</p>
<p>可以使用<code>document.createDocumentFragment()</code>方法创建文档片段。</p>
<h2 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h2><p>Attr类型的节点是存在于元素attributes属性中的节点。Attr节点具有以下特征：</p>
<ul>
<li>nodeType的值等于2。</li>
<li>nodeName值为属性名。</li>
<li>nodeValue值为属性值。</li>
<li>parentNode值为null。</li>
<li>在HTML中不支持子节点。</li>
<li>在XML中子节点可以是Text或EntityReference。</li>
</ul>
<p>属性节点尽管是节点，却不被认为是DOM文档树的一部分。Attr节点很少直接被引用，通常开发者更喜欢使用<code>getAttribute()</code>、<code>removeAttribute()</code>和<code>setAttribute()</code>方法操作属性。</p>
<p>Attr对象上有3个属性：</p>
<ul>
<li>name：包含属性名（与nodeName一样）。</li>
<li>value：包含属性值（与nodeValue一样）。</li>
<li>specified：一个布尔值，表示属性使用的是默认值还是被指定的值。</li>
</ul>
<p>可以使用<code>document.createAttribute()</code>方法创建新的Attr节点，参数为属性名。可以使用元素的<code>setAttributeNode()</code>方法将这个属性添加到元素上。</p>
<h1 id="DOM编程"><a href="#DOM编程" class="headerlink" title="DOM编程"></a>DOM编程</h1><p>除了操作常规的页面元素之外，还有一些特殊的页面内容可以被操作。</p>
<h2 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h2><p>使用JS可以动态地向页面上添加脚本，实现的方式为向页面添加script标签。</p>
<h3 id="插入外部JS文件"><a href="#插入外部JS文件" class="headerlink" title="插入外部JS文件"></a>插入外部JS文件</h3><p>我们通常这样在页面上引用JS文件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;foo.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>那么我们就可以通过创建script标签——设置src属性——添加到页面这样的方式来引入JS文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;script&quot;</span>);<br>script.src = <span class="hljs-string">&quot;foo.js&quot;</span>;<br><span class="hljs-built_in">document</span>.body.appendChild(script);<br></code></pre></td></tr></table></figure>

<p>注意：在把<code>&lt;script&gt;</code>元素添加到页面之前，是不会开始下载外部文件的。</p>
<p>当然也可以把它添加到<code>&lt;head&gt;</code>元素，同样可以实现动态脚本加载。</p>
<p>这个过程可以抽象为一个函数，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadScript</span>(<span class="hljs-params">url</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;script&quot;</span>);<br>    script.src = url;<br>    <span class="hljs-built_in">document</span>.body.appendChild(script);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="插入内联JS代码"><a href="#插入内联JS代码" class="headerlink" title="插入内联JS代码"></a>插入内联JS代码</h3><p>即插入像这样的script标签：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        alert(<span class="hljs-string">&quot;hi&quot;</span>);</span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>那么有两种方法。</p>
<p><strong>方法一</strong>：创建script标签，为其添加一个Text子节点，Text内容为JS代码字符串。即：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;script&quot;</span>);<br>script.appendChild(<span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">&quot;function sayHi()&#123;alert(&#x27;hi&#x27;); &#125;&quot;</span>));<br><span class="hljs-built_in">document</span>.body.appendChild(script);<br></code></pre></td></tr></table></figure>

<p><strong>方法二</strong>：创建script标签，为其设置text属性来添加JS代码字符串。即：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;script&quot;</span>);<br>script.text = <span class="hljs-string">&quot;functionsayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;</span>;<br><span class="hljs-built_in">document</span>.body.appendChild(script);<br></code></pre></td></tr></table></figure>

<p>由于兼容性问题，旧版本的IE中不支持方法一中的访问script标签子节点，而Safari 3之前的版本不能正确支持方法二中的text属性，因此综合起来考虑兼容性，有以下方案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadScriptString</span>(<span class="hljs-params">code</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;script&quot;</span>);<br>    script.type = <span class="hljs-string">&quot;text/javascript&quot;</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        script.appendChild(<span class="hljs-built_in">document</span>.createTextNode(code));<br>    &#125; <span class="hljs-keyword">catch</span> (ex) &#123;<br>        script.text = code;<br>    &#125;<br>    <span class="hljs-built_in">document</span>.body.appendChild(script);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>以这种方式加载的代码会在全局作用域中执行，并在调用返回后立即生效。</strong>基本上，这就相当于在全局作用域中把源代码传给<code>eval()</code>方法。</p>
<p>注意：通过innerHTML属性创建的<code>&lt;script&gt;</code>元素<strong>永远不会执行</strong>。这样浏览器仍然会创建<code>&lt;script&gt;</code>元素和其中的内容，但解析器会给这个<code>&lt;script&gt;</code>元素打上永不执行的标签。</p>
<h2 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h2><p>CSS样式在HTML页面中可以通过两个元素加载：<code>&lt;link&gt;</code>元素用于包含CSS外部文件，而<code>&lt;style&gt;</code>元素用于添加嵌入样式。动态样式也是通过这两个元素像加载动态脚本一样加载的，</p>
<p>通过<code>&lt;link&gt;</code>元素加载外部的样式表和加载外部的动态脚本一样很容易，而使用<code>&lt;style&gt;</code>元素加载嵌入的样式会出现和加载嵌入的脚本一样的问题：低版本的IE不允许访问<code>&lt;style&gt;</code>元素的内部节点，因此需要使用cssText属性代替。</p>
<p>但对于IE要小心使用<code>styleSheet.cssText</code>：如果重用同一个<code>&lt;style&gt;</code>元素并设置该属性超过一次，则可能导致浏览器崩溃。同样，将cssText设置为空字符串也可能导致浏览器崩溃。</p>
<p>动态添加的样式会<strong>立即生效</strong>，所有变化都会立即反映出来。</p>
<h2 id="操作表格"><a href="#操作表格" class="headerlink" title="操作表格"></a>操作表格</h2><p>表格是HTML中最复杂的结构之一。通过DOM编程创建<code>&lt;table&gt;</code>元素，通常要涉及大量标签，包括表行、表元、表题等。</p>
<p>为了方便操作表格，HTML DOM给<code>&lt;table&gt;</code>、<code>&lt;tbody&gt;</code>和<code>&lt;tr&gt;</code>元素添加了一些属性和方法，这些属性和方法极大地减少了创建表格所需的代码量。</p>
<h3 id="table元素"><a href="#table元素" class="headerlink" title="table元素"></a>table元素</h3><p><code>&lt;table&gt;</code>元素上添加了以下属性和方法：</p>
<ul>
<li><code>caption</code>：指向<code>&lt;caption&gt;</code>元素（如果存在）。</li>
<li><code>tBodies</code>：包含<code>&lt;tbody&gt;</code>元素的HTMLCollection。</li>
<li><code>tFoot</code>：指向<code>&lt;tfoot&gt;</code>元素（如果存在）。</li>
<li><code>tHead</code>：指向<code>&lt;thead&gt;</code>元素（如果存在）。</li>
<li><code>rows</code>：包含表示所有行的HTMLCollection。</li>
<li><code>createTHead()</code>：创建<code>&lt;thead&gt;</code>元素，放到表格中，返回引用。</li>
<li><code>createTFoot()</code>：创建<code>&lt;tfoot&gt;</code>元素，放到表格中，返回引用。</li>
<li><code>createCaption()</code>：创建<code>&lt;caption&gt;</code>元素，放到表格中，返回引用。</li>
<li><code>deleteTHead()</code>：删除<code>&lt;thead&gt;</code>元素。</li>
<li><code>deleteTFoot()</code>：删除<code>&lt;tfoot&gt;</code>元素。</li>
<li><code>deleteCaption()</code>：删除<code>&lt;caption&gt;</code>元素。</li>
<li><code>deleteRow(pos)</code>：删除给定位置的行。</li>
<li><code>insertRow(pos)</code>：在行集合中给定位置插入一行。</li>
</ul>
<h3 id="tbody元素"><a href="#tbody元素" class="headerlink" title="tbody元素"></a>tbody元素</h3><p><code>&lt;tbody&gt;</code>元素上添加了以下属性和方法：</p>
<ul>
<li><code>rows</code>：包含<code>&lt;tbody&gt;</code>元素中所有行的HTMLCollection。</li>
<li><code>deleteRow(pos)</code>：删除给定位置的行。</li>
<li><code>insertRow(pos)</code>：在行集合中给定位置插入一行，返回该行的引用。</li>
</ul>
<h3 id="tr元素"><a href="#tr元素" class="headerlink" title="tr元素"></a>tr元素</h3><p><code>&lt;tr&gt;</code>元素上添加了以下属性和方法：</p>
<ul>
<li><code>cells</code>：包含<code>&lt;tr&gt;</code>元素所有表元的HTMLCollection。</li>
<li><code>deleteCell(pos)</code>：删除给定位置的表元。</li>
<li><code>insertCell(pos)</code>：在表元集合给定位置插入一个表元，返回该表元的引用。</li>
</ul>
<h2 id="NodeList对象"><a href="#NodeList对象" class="headerlink" title="NodeList对象"></a>NodeList对象</h2><p>NodeList对象和其相关的NamedNodeMap、HTMLCollection对象在DOM编程中具有重要地位。</p>
<p>虽然设计者的初衷是使得这三种对象都是实时的，在规范中也说明了它们是实时的，但是<strong>由于性能的原因，浏览器在实现它们的时候，并不一定将其实现为实时的集合</strong>。</p>
<p>大多浏览器仅将<code>Node.childNodes</code>返回的是NodeList对象设计为实时的，而<strong>其他情况下都是静态的</strong>，如<code>document.querySelectorAll()</code>方法就会返回一个静态NodeList。</p>
<p>而<code>NamedNodeMap对象和HTMLCollection对象总是实时的</code>。</p>
<p>由于历史原因，在DOM4之前，实现该接口的集合只能包含HTML元素，因此该接口才被称为HTMLCollection。</p>
<p>要注意<strong>动态的DOM集合很容易在遍历时陷入死循环</strong>，比如当你每次遍历都在往其中加入内容时，导致列表中的DOM元素反而越遍历越多，永远也遍历不完了。因此在遍历动态集合时，最好采用计数变量的循环方式，使得计数变量与集合的length属性作比较来决定循环的进行，当然更多时候最合适的做法是拷贝一份实时集合的静态副本，在静态副本上进行遍历。</p>
<h1 id="MutationObserver接口"><a href="#MutationObserver接口" class="headerlink" title="MutationObserver接口"></a>MutationObserver接口</h1><p>MutationObserver接口<strong>可以在DOM被修改时异步执行回调</strong>，使用MutationObserver可以观察整个文档的各个部分的变化。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>MutationObserver的实例要通过调用MutationObserver构造函数并传入一个回调函数来创建：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;DOM was mutated! &#x27;</span>));<br></code></pre></td></tr></table></figure>

<h3 id="observe方法"><a href="#observe方法" class="headerlink" title="observe方法"></a>observe方法</h3><p>新创建的MutationObserver实例不会关联DOM的任何部分，要把这个observer与DOM关联起来，需要使用<code>observe()</code>方法。</p>
<p>这个方法接收两个必需的参数：要观察其变化的DOM节点，以及一个MutationObserverInit对象。</p>
<p>MutationObserverInit对象用于控制观察哪些方面的变化，是一个键/值对形式配置选项的字典。</p>
<p>例如，下面的代码会创建一个观察者（observer）并配置它观察<code>&lt;body&gt;</code>元素上的属性变化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&lt;body&gt; attributes changed&#x27;</span>));<br>observer.observe(<span class="hljs-built_in">document</span>.body, &#123;<br>    <span class="hljs-attr">attributes</span>: <span class="hljs-literal">true</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>执行以上代码后，<code>&lt;body&gt;</code>元素上任何属性发生变化都会被这个MutationObserver实例发现，然后就会异步执行注册的回调函数，而<code>&lt;body&gt;</code>元素后代的修改或其他非属性修改都不会触发回调进入任务队列。</p>
<p>这里的回调函数是异步的，并<strong>不会阻塞DOM变化</strong>。</p>
<h3 id="MutationRecord"><a href="#MutationRecord" class="headerlink" title="MutationRecord"></a>MutationRecord</h3><p>回调函数会收到一个MutationRecord实例的数组（队列）作为参数，此外传给回调函数的第二个参数是观察变化的MutationObserver的实例。</p>
<p>MutationRecord实例包含的信息包括DOM的哪一部分发生了什么变化。因为回调是异步执行的，执行之前可能同时发生多个满足观察条件的事件，传入的参数是<strong>一个包含按顺序入队的MutationRecord实例的数组</strong>。</p>
<p>MutationRecord实例具有的属性如下：<br><img   class="lazyload" data-original="/images/illustration/2022-02-13-js012/001.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<h3 id="disconnect方法"><a href="#disconnect方法" class="headerlink" title="disconnect方法"></a>disconnect方法</h3><p>默认情况下，只要被观察的元素不被垃圾回收，MutationObserver的回调就会响应DOM变化事件，要提前终止执行回调，可以调用<code>disconnect()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&lt;body&gt; attributes changed&#x27;</span>));<br>observer.observe(<span class="hljs-built_in">document</span>.body, &#123;<br>    <span class="hljs-attr">attributes</span>: <span class="hljs-literal">true</span><br>&#125;);<br>observer.disconnect();<br></code></pre></td></tr></table></figure>

<h3 id="复用和重用"><a href="#复用和重用" class="headerlink" title="复用和重用"></a>复用和重用</h3><p>多次调用<code>observe()</code>方法，可以使用同一个MutationObserver对象观察多个不同的目标节点，此时，可以通过MutationRecord的target属性来区分目标节点。</p>
<p>而<code>disconnect()</code>方法是一个“一刀切”的方案，它会<strong>使观察者停止观察所有目标</strong>。</p>
<p>但<code>disconnect()</code>并不会结束MutationObserver的生命，我们还可以重新使用这个观察者，再调用<code>observe()</code>方法将它关联到新的目标节点。</p>
<h2 id="观察范围"><a href="#观察范围" class="headerlink" title="观察范围"></a>观察范围</h2><p>MutationObserverInit对象可以控制对目标节点的观察范围（观察目标的哪些变化）。</p>
<p>观察者可以观察的事件包括<strong>属性变化、文本变化和子节点变化</strong>。</p>
<p>以下是可以通过MutationObserverInit对象进行的配置：<br><img   class="lazyload" data-original="/images/illustration/2022-02-13-js012/002.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<h2 id="记录队列"><a href="#记录队列" class="headerlink" title="记录队列"></a>记录队列</h2><p>MutationObserver接口出于性能考虑以<strong>异步回调与记录队列模型</strong>为核心。</p>
<p>为了在大量变化事件发生时不影响性能，每次观察到的变化信息会保存在MutationRecord实例中，然后添加到记录队列。<strong>这个队列对每个MutationObserver实例都是唯一的，是所有监听的DOM变化事件的有序列表。</strong></p>
<p>MutationObserver的回调函数会进入<strong>微任务队列</strong>，并且是在队列中没有相同的任务时才会进入队列，防止回调函数重复执行。因此在回调函数中要负责处理队列中的每一个MutationRecord实例，否则函数结束后就认为这些记录变化的MutationRecord实例已经被处理过了，因此会清空它们导致内容丢失。</p>
<p>调用MutationObserver实例的<code>takeRecords()</code>方法可以清空记录队列，取出并返回其中的所有MutationRecord实例。这在希望断开与观察目标的联系，但又希望处理由于调用<code>disconnect()</code>而被抛弃的记录队列中的MutationRecord实例时非常有用。</p>
<h2 id="内存与性能"><a href="#内存与性能" class="headerlink" title="内存与性能"></a>内存与性能</h2><p>MutationObserver实例与目标节点之间的引用关系是非对称的，MutationObserver仅拥有目标节点的<strong>弱引用</strong>，不会妨碍垃圾回收程序回收目标节点；而目标节点却拥有对MutationObserver的<strong>强引用</strong>。</p>
<p>如果所有的目标节点从DOM中被移除，随后被垃圾回收，关联的MutationObserver又没有其他引用的话，该MutationObserver对象会被垃圾回收。</p>
<p>每个MutationRecord实例都会包含对已有一个或多个DOM节点的引用，记录队列和回调处理的默认行为是耗尽这个队列，处理每个MutationRecord，然后让它们超出作用域并被垃圾回收。</p>
<p>如果保存这些MutationRecord实例，会妨碍它引用的节点被回收。因此最好<strong>从每个MutationRecord中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃MutationRecord</strong>。</p>

      </section>
      <section class="extra">
        <!-- 
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>Dasen Sun</li>
    <li><strong>本文链接：</strong><a href="http://example.com/2022/02/13/js012/index.html" title="http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;02&#x2F;13&#x2F;js012&#x2F;index.html">http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;02&#x2F;13&#x2F;js012&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
         -->
        
          <br>
          <center><hr></center>
          <br>
          <center>* 你好，我是大森。如果文章内容帮到了你，你可通过下方付款二维码支持作者 *</center>
          <br>
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="/images/qrcode/alipay.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
          <center><hr></center>
          <br>
        
        
        
  <nav class="nav">
    <a></a>
    <a href="/2022/02/09/frontend-css-008/">CSS：深入内联元素 <i class="iconfont iconright"></i><i class="iconfont iconright"></i></a>
  </nav>

      </section>
      <!--  -->
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DOM%E8%8A%82%E7%82%B9"><span class="toc-text">DOM节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9"><span class="toc-text">节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nodeType%E5%B1%9E%E6%80%A7"><span class="toc-text">nodeType属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nodeName%E5%B1%9E%E6%80%A7"><span class="toc-text">nodeName属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nodeValue%E5%B1%9E%E6%80%A7"><span class="toc-text">nodeValue属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#childNodes%E5%B1%9E%E6%80%A7"><span class="toc-text">childNodes属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parentNode%E5%B1%9E%E6%80%A7"><span class="toc-text">parentNode属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#previousSibling%E5%B1%9E%E6%80%A7%E5%92%8CnextSibling%E5%B1%9E%E6%80%A7"><span class="toc-text">previousSibling属性和nextSibling属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#firstChild%E5%B1%9E%E6%80%A7%E5%92%8ClastChild%E5%B1%9E%E6%80%A7"><span class="toc-text">firstChild属性和lastChild属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ownerDocument%E5%B1%9E%E6%80%A7"><span class="toc-text">ownerDocument属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hasChildNodes%E6%96%B9%E6%B3%95"><span class="toc-text">hasChildNodes方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#appendChild%E6%96%B9%E6%B3%95"><span class="toc-text">appendChild方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insertBefore%E6%96%B9%E6%B3%95"><span class="toc-text">insertBefore方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replaceChild%E6%96%B9%E6%B3%95"><span class="toc-text">replaceChild方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#removeChild%E6%96%B9%E6%B3%95"><span class="toc-text">removeChild方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cloneNode%E6%96%B9%E6%B3%95"><span class="toc-text">cloneNode方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#normalize%E6%96%B9%E6%B3%95"><span class="toc-text">normalize方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Document%E7%B1%BB%E5%9E%8B"><span class="toc-text">Document类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#documentElement%E5%B1%9E%E6%80%A7"><span class="toc-text">documentElement属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#body%E5%B1%9E%E6%80%A7"><span class="toc-text">body属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#doctype%E5%B1%9E%E6%80%A7"><span class="toc-text">doctype属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#title%E5%B1%9E%E6%80%A7"><span class="toc-text">title属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7"><span class="toc-text">链接属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">获取元素的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E9%9B%86%E5%90%88"><span class="toc-text">特殊集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E5%85%BC%E5%AE%B9%E6%80%A7%E6%A3%80%E6%B5%8B"><span class="toc-text">DOM兼容性检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E5%86%99%E5%85%A5"><span class="toc-text">文档写入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Element%E7%B1%BB%E5%9E%8B"><span class="toc-text">Element类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML%E5%85%83%E7%B4%A0"><span class="toc-text">HTML元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="toc-text">获取元素属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#attributes%E5%B1%9E%E6%80%A7"><span class="toc-text">attributes属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0"><span class="toc-text">创建元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Text%E7%B1%BB%E5%9E%8B"><span class="toc-text">Text类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Comment%E7%B1%BB%E5%9E%8B"><span class="toc-text">Comment类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CDATASection%E7%B1%BB%E5%9E%8B"><span class="toc-text">CDATASection类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DocumentType%E7%B1%BB%E5%9E%8B"><span class="toc-text">DocumentType类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DocumentFragment%E7%B1%BB%E5%9E%8B"><span class="toc-text">DocumentFragment类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Attr%E7%B1%BB%E5%9E%8B"><span class="toc-text">Attr类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DOM%E7%BC%96%E7%A8%8B"><span class="toc-text">DOM编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%84%9A%E6%9C%AC"><span class="toc-text">动态脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%A4%96%E9%83%A8JS%E6%96%87%E4%BB%B6"><span class="toc-text">插入外部JS文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%86%85%E8%81%94JS%E4%BB%A3%E7%A0%81"><span class="toc-text">插入内联JS代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%A0%B7%E5%BC%8F"><span class="toc-text">动态样式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E8%A1%A8%E6%A0%BC"><span class="toc-text">操作表格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#table%E5%85%83%E7%B4%A0"><span class="toc-text">table元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tbody%E5%85%83%E7%B4%A0"><span class="toc-text">tbody元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tr%E5%85%83%E7%B4%A0"><span class="toc-text">tr元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NodeList%E5%AF%B9%E8%B1%A1"><span class="toc-text">NodeList对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MutationObserver%E6%8E%A5%E5%8F%A3"><span class="toc-text">MutationObserver接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B"><span class="toc-text">创建实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#observe%E6%96%B9%E6%B3%95"><span class="toc-text">observe方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MutationRecord"><span class="toc-text">MutationRecord</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#disconnect%E6%96%B9%E6%B3%95"><span class="toc-text">disconnect方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8%E5%92%8C%E9%87%8D%E7%94%A8"><span class="toc-text">复用和重用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%8C%83%E5%9B%B4"><span class="toc-text">观察范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%98%9F%E5%88%97"><span class="toc-text">记录队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%8E%E6%80%A7%E8%83%BD"><span class="toc-text">内存与性能</span></a></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="https://www.instagram.com/zhangsiyu_2/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/sadose/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:sadose@qq.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  孙大森 - 2021</p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>