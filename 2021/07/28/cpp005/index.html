

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>C++学习笔记（5）：语句和表达式 - 大森的博客</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="表达式表达式概念表达式、运算对象和运算符表达式由一个或...">
  <meta name="author" content="Dasen Sun">
  <link rel="icon" href="/images/icons/logo-16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/logo-32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/logo-180.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/logo-144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_r673sha78lq.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '[object Object]'
      },
      donate: {
        enable: true,
        alipay: '/images/qrcode/alipay.jpg',
        wechat: '/images/qrcode/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '人生如逆旅，我亦是行人。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: '/images/qrcode/qrcode.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: false,
        path: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
    </div>
    <div class="center">C++学习笔记（5）：语句和表达式</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>　
      </li><li class="menu-item">
        <a href="/categories/cpp/ " class="underline "> C++</a>　
      </li><li class="menu-item">
        <a href="/categories/frontend/ " class="underline "> HTML/CSS</a>　
      </li><li class="menu-item">
        <a href="/categories/js/ " class="underline "> JavaScript</a>　
      </li><li class="menu-item">
        <a href="/categories/notes/ " class="underline "> 课程笔记</a>　
      </li><li class="menu-item">
        <a href="/categories/tools/ " class="underline "> 工具</a>　
      </li><li class="menu-item">
        <a href="/categories/other/ " class="underline "> 其他</a>　
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>　
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  孙大森 - 2021</p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/post/cpp.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">C++学习笔记（5）：语句和表达式</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>July 28, 2021</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>7983</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h2 id="表达式概念"><a href="#表达式概念" class="headerlink" title="表达式概念"></a>表达式概念</h2><h3 id="表达式、运算对象和运算符"><a href="#表达式、运算对象和运算符" class="headerlink" title="表达式、运算对象和运算符"></a>表达式、运算对象和运算符</h3><p><strong>表达式</strong>由一个或多个<strong>运算对象</strong>组成，一个运算对象本身即可成为表达式，一个运算对象（字面值和变量）也可有运算符，多个运算对象必须由运算符连接。</p>
<p>对表达式求值将得到一个结果，即<strong>表达式一定是有值的</strong>。</p>
<p>运算符按照运算对象的个数主要分为<strong>一元运算符</strong>、<strong>二元运算符</strong>和<strong>三元运算符</strong>，此外函数调用也是一种特殊的运算符，它的运算对象个数没有限制，依函数所需的参数而定。</p>
<p>有些运算符有多种含义，具体表示为何种含义由上下文而定，在表示不同含义时，同一运算符可能有不同优先级和结合律。</p>
<h3 id="优先级、结合律和求值顺序"><a href="#优先级、结合律和求值顺序" class="headerlink" title="优先级、结合律和求值顺序"></a>优先级、结合律和求值顺序</h3><p>运算符优先级规定了在复杂的表达式中，哪些运算会首先进行运算，我们可以使用括号运算符使某些运算首先进行，从而改变运算顺序。</p>
<p>结合律规定了运算符和运算对象的结合方向。</p>
<p><strong>求值顺序</strong>决定了一个运算符的若干运算对象中哪个先进行求值，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-built_in">f1</span>()*<span class="hljs-built_in">f2</span>();<br></code></pre></td></tr></table></figure>
<p>中，我们可以确定的是f1和f2两个函数都在乘法进行之前求值，但是我们并不知道两个函数中谁先进行求值，这就是由求值顺序规定的。</p>
<p>左移运算符&lt;&lt;未规定对象的求值顺序，那么以下代码的输出结果就是未定义的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ++i &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>因为我们不知道i和++i哪个先求值，在编写代码时应当避免这种表达方式。</p>
<p>实际上，C++的大部分运算符都没有规定求值顺序，只有四种运算符明确规定了运算对象的求值顺序：</p>
<ul>
<li>逻辑与运算符&amp;&amp;：从左到右求值（方便实现短路逻辑）。</li>
<li>逻辑或运算符||：从左到右求值。</li>
<li>条件运算符：先求值条件，再根据分支求值相应的表达式。</li>
<li>逗号运算符：从左到右求值。</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">说明</th>
<th align="center">结合顺序</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">一元正号</td>
<td align="center">从右到左</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">一元负号</td>
<td align="center">从右到左</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘法</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">除法</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">求余</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">加法</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减法</td>
<td align="center">从左到右</td>
</tr>
</tbody></table>
<p>不同类型的数据在同一个表达式中进行复合算术运算时，所有运算对象都隐式转换为同一类型。</p>
<p>一元正号运算符一般用于创建一个变量的副本（虽然好像没有什么用）。</p>
<p><strong>布尔值不应当参与算术运算</strong>，其结果往往比较出人意料，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> b1 = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">bool</span> b2 = -b1;<br></code></pre></td></tr></table></figure>
<p>b2的结果仍然是true，原因是这样的：b1首先被转换为int参与运算，真值转换为1，取负后是-1，这时候再将它赋值给b2转换为布尔值，得到的还是true（非0值都是真）。</p>
<p>求余运算符%只能作用于整数，它的两个运算对象都只能是整数，对于负数的情况：</p>
<ul>
<li>m%(-n)等于m%n。</li>
<li>(-m)%n等于-(m%n)。</li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">说明</th>
<th align="center">结合顺序</th>
</tr>
</thead>
<tbody><tr>
<td align="center">!</td>
<td align="center">逻辑非</td>
<td align="center">从右到左</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">小于等于</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">大于等于</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">==</td>
<td align="center">相等</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">不相等</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">&amp;&amp;</td>
<td align="center">逻辑与</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">||</td>
<td align="center">逻辑或</td>
<td align="center">从左到右</td>
</tr>
</tbody></table>
<p>关系运算符都是从左到右的结合方向，要注意比较时不能连续比较。</p>
<p>关系运算符在运算时也会进行隐式类型转换，那么就意味着在进行布尔值比较时要格外注意，假如我们要判断val的值是不是非0，我们可以直接这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(val) …;<br></code></pre></td></tr></table></figure>
<p>但是如果我们这样表达：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(val==<span class="hljs-literal">true</span>) …;<br></code></pre></td></tr></table></figure>
<p>看起来没什么区别，但实际上区别可大了。在比较val==true时，会进行类型转换，按照往大类型转换的原则，假如val是整数，那么比较过程中会把true转换为1，所以实际上比较的是val==1，这样就与我们的本意（判断val是否非0）相违背了。</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><strong>短路逻辑</strong>：</p>
<ul>
<li>逻辑与运算符&amp;&amp;当左侧表达式为假时将不会再验证右侧表达式的值，直接返回假，只有当左侧表达式为真时才会验证右侧。</li>
<li>逻辑或运算符||当左侧表达式为真时将不会再验证右侧表达式的值，直接返回真，只有当左侧表达式为假时才会验证右侧。</li>
</ul>
<p>短路逻辑使得程序运行的效率更高，并且可以进行较为复杂的判断（右侧表达式有可能允许为不合法的，此时左侧表达式是为了确保右侧表达式的正确性和安全性）。</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">说明</th>
<th align="center">结合顺序</th>
</tr>
</thead>
<tbody><tr>
<td align="center">~</td>
<td align="center">按位取反</td>
<td align="center">从右到左</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center">左移</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">右移</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">按位与</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">按位异或</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">按位或</td>
<td align="center">从左到右</td>
</tr>
</tbody></table>
<p>在使用位运算时，如果运算对象是“小整型”，则它的值会被自动提升成较大的整数类型。</p>
<p>运算对象可以是带符号的，也可以是无符号的，如果运算对象是带符号的且它的值为负，那么位运算符如何处理运算对象的“符号位”依赖于机器，这是一种未定义的行为。因此建议对无符号类型使用移位运算。</p>
<p>移位运算符右侧的运算对象一定<strong>不能为负</strong>，并且其值要严格小于结果的位数，否则会产生未定义行为。</p>
<p>在对char类型进行运算时，会将其提升为int类型，高位补0。</p>
<p>移位运算符满足从左到右的结合顺序。</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符的左侧运算对象应当是一个可修改的左值，表达式的值是赋值完成后左侧运算对象的值。</p>
<p>C++11标准允许使用列表作为赋值运算符的右侧运算对象，同时如果左侧运算对象为内置类型，列表中最多只能包含一个值，并且如果发生类型转换，不能有精度损失；如果左侧运算对象为内置容器，可以像列表初始化一样给它赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt; vi;<br>vi = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br></code></pre></td></tr></table></figure>

<p>可以这样做的原因是vector重载了赋值运算符，并且可以接收初始值列表，如果vi并不是空的，它的元素将被右侧列表中的值替换。</p>
<p>无论左侧运算对象是什么类型，初始值都可以为空，此时编译器将创建一个经过了<strong>值初始化</strong>的临时变量并赋值给左侧运算对象。</p>
<p>赋值运算满足从右到左的结合顺序，这和大部分二元运算符不同，因此这使得连续赋值成为了可能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a=b=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>对于算术运算和位运算，提供了复合赋值运算符，包括+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&amp;=、^=、|=。</p>
<p>复合运算符除了性能稍优于普通赋值之外，并没有太大区别。</p>
<h3 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h3><p>递增运算符和递减运算符为对象的加1和减1操作提供了一种简洁的书写形式，同时这两个运算符还<strong>可应用于迭代器</strong>。</p>
<p>递增递减运算符可作为<strong>前置</strong>运算符也可作为<strong>后置</strong>运算符，前置将对象本身作为左值返回，后置则将对象原始值的副本作为右值返回，如++i将会把i的值自增1并返回i，即先自增再使用，而i++则会保存一个i的副本，再让i自增1，表达式返回没有自增前的副本，也就是先使用，再自增。前置返回的是一个左值，而后置返回的是一个临时的副本，因此是个不可操作的右值。</p>
<p>除非必须，否则建议不用后置的递增递减运算符，因为<strong>后置的性能不如前置</strong>，它需要用到一个临时的副本。</p>
<p>对于指针和迭代器，我们在循环时往往需要在循环的结束对其进行自增自减，而如果对其的操作较为简单的话，我们可以在操作的同时顺带使其自增自减，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> pbeg = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (pbeg != v.<span class="hljs-built_in">end</span>() &amp;&amp; *beg &gt;=<span class="hljs-number">0</span>)<br>    cout &lt;&lt; *pbeg++ &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>其中*pbeg++等价于*(pbeg++)，也就是把迭代器自增之后，使用其自增之前的值，可以这样做的原因是自增运算符++的优先级要高于解引用运算符*。</p>
<h3 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h3><p>成员访问运算符有两种，分别是<strong>点运算符</strong>和<strong>箭头运算符</strong>，点运算符直接对对象使用，箭头运算符对指针或迭代器使用，即p-&gt;m等价于(*p).m。</p>
<p>注意由于解引用运算符*和成员访问运算符.的优先级问题，(*p).m和*p.m是截然不同的含义。</p>
<h3 id="强制类型转换运算符"><a href="#强制类型转换运算符" class="headerlink" title="强制类型转换运算符"></a>强制类型转换运算符</h3><p>强制类型转换的方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cast-name&lt;type&gt;(expression);<br></code></pre></td></tr></table></figure>
<p>其中，type是转换的目标类型，而expression是要转换的值。如果type是引用类型，则结果是左值。<br>cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。<br>dynamic_cast支持运行时类型识别，此处先按下不提。</p>
<p>cast-name指定了执行的是哪种转换：</p>
<ul>
<li>static_cast：具有明确定义的类型转换，但<strong>不能包含底层const</strong>，如常规的想把int转换为double。使用static_cast时，意味着我们告诉编译器大胆地进行类型转换，我们不在乎精度的损失，这时编译器不会因为类型不匹配而发出警告信息。此外，也可以使用static_cast将void *转换回原来的指针类型，从而找回存放于void *中的值。</li>
<li>const_cast：用于<strong>去掉对象的底层const</strong>，可以将常量对象转换为非常量对象，也就是去掉const性质，如将常量指针pc转换为普通指针p，就可以通过p修改指向的值了，这样就使用强制类型转换获得了写权限。</li>
<li>reinterpret_cast：运算对象的位模式提供较低层次上的重新解释。比如把一个整型指针转换为字符型指针，这样的转换是<strong>危险</strong>的，只能在特殊的情况下使用。</li>
</ul>
<p>由于C++对于C语言兼容，因此C风格的类型转换也是可以使用的，但是还是建议使用C++的类型转换方式以控制风险。</p>
<h3 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h3><p>sizeof运算符返回一条表达式或一个类型名字所占的<strong>字节数</strong>。</p>
<p>两种使用方式：sizeof(type)或sizeof expr，sizeof并<strong>不实际计算表达式的值</strong>，只是进行了类型判断，然后返回类型的尺寸。</p>
<p>sizeof运算符满足<strong>右结合律</strong>，其所得的值是一个size_t类型的<strong>常量表达式</strong>。</p>
<p>此外，sizeof运算符还有以下特点：</p>
<ul>
<li>对char或者类型为char的表达式执行sizeof运算，结果得1。</li>
<li>对引用类型执行sizeof运算得到被引用对象所占空间的大小。</li>
<li>对指针执行sizeof运算得到指针本身所占空间的大小。</li>
<li>对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效。</li>
<li>对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。</li>
<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</li>
</ul>
<p>因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数。又由于sizeof的返回值是一个常量表达式，所以我们<strong>可以用sizeof的结果声明数组的维度</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> sz = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ia)/<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(*ia);<br><span class="hljs-keyword">int</span> arr2[sz];<br></code></pre></td></tr></table></figure>

<h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><p>（1）条件运算符（?:）：条件运算符允许我们把简单的条件判断嵌入到一个表达式中。当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值，否则是右值。使用时要注意优先级，保险起见，可以添加额外的括号。</p>
<p>（2）逗号运算符：可以将多条表达式连接成一个表达式，各个表达式从左到右求值，最后整个表达式的值是<strong>最后一个表达式的值</strong>，如果最后一个表达式的值为左值，那么最终的结果也是左值。</p>
<h2 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h2><p><img   class="lazyload" data-original="/images/illustration/2021-07-28-cpp005/001.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h2><h3 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h3><p>在表达式的末尾加上表示语句结束的分号就成为了表达式语句。</p>
<p>表达式语句的作用就是<strong>执行表达式并丢掉其结果</strong>，因此只求值，没有副作用的表达式语句是无意义的。</p>
<p>由于表达式的本质使命是（通过运算）得出一个值，如a+5将得到变量a加上5的值，但是如果直接给这个表达式加上分号，那么这个值不被使用就成了完全无意义的，因此这种只发挥了表达式本职使命（运算求值）的表达式语句是没有意义的，于是另一种“不务正业”的表达式语句就有了意义，也就是这类表达式具有除了运算求值之外的副作用。</p>
<p>如果表达式在执行的过程中除了得到表达式的运算结果值之外，还产生了一些别的影响，那么这类表达式就是有意义的，这种影响被称为<strong>副作用</strong>，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>, b;<br>b = a + <span class="hljs-number">1</span>;<br>cout &lt;&lt; b &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>我们可以看到其中b = a + 1作为表达式其结果值为6，但是这个表达式在求解结果的同时还使得b的值改变了，这种改变了b的值的影响就叫做副作用；同样地，cout &lt;&lt; b &lt;&lt; endl作为表达式，其结果是cout，但是它还产生了其他影响，即在屏幕上输出内容，这也是它的副作用。这两条语句都是非单纯求值的表达式，都产生了副作用，因此它们都是有意义的表达式语句。</p>
<h3 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h3><p>空语句是最简单的语句，它只由一个分号组成，通常用于占位，用来解决<strong>语法上需要语句但是逻辑上不需要语句</strong>的情况，如循环体为空的空循环。</p>
<h3 id="复合语句"><a href="#复合语句" class="headerlink" title="复合语句"></a>复合语句</h3><p>使用一对花括号括起来的一系列语句为复合语句，复合语句可视为一条语句，在复合语句的语句块中引入的名字只在块内（及其子块内）可见。</p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h3><p>条件语句一般有以下形式：</p>
<ul>
<li>if语句：单一条件。</li>
<li>if-else语句：如果-否则，双向跳转。</li>
<li>if-(else if)-else语句：多重判断，多向跳转，中间可有任意多个else if，最后的else可无。</li>
</ul>
<p>条件语句<strong>可嵌套</strong>，嵌套的条件语句的else配对遵循<strong>就近原则</strong>，else和它前方最近的一个未配对if进行配对。</p>
<h3 id="switch条件语句"><a href="#switch条件语句" class="headerlink" title="switch条件语句"></a>switch条件语句</h3><p>switch语句能使我们在若干<strong>固定选项</strong>中做出选择。</p>
<p>switch将求出括号中的表达式的值，并将该值转换为整数类型，与每个case比较，跳转到命中的case标签处开始往后执行，直到遇到一个break或到了switch末尾。</p>
<p>因此一般情况下会在每个case结束时加上一条break语句，并且不建议使用小数等非整数类型进行判断。</p>
<p>多个case可以连续使用。default是一种特殊的case标签，将作为缺省case使用。</p>
<p>case进行跳转时要注意变量定义的问题，不要在switch中定义变量，因为<strong>从变量的定义域之外不经该变量的定义过程跳转到该变量的定义域内是非法行为</strong>。</p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>条件成立则进入循环，即<strong>先判断再循环</strong>，当条件一开始就不成立时可能一次也不循环，即循环0次。</p>
<h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h3><p>直接进入循环，每次<strong>循环后进行判断</strong>，条件成立则循环继续，即先循环再判断，无论如何也会进行至少一次循环。</p>
<p>while和do-while循环一般用于不确定循环次数但是确定边界条件时。</p>
<h3 id="传统for循环"><a href="#传统for循环" class="headerlink" title="传统for循环"></a>传统for循环</h3><p>格式为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(A; B; C)&#123; … &#125;<br></code></pre></td></tr></table></figure>
<p>其中A为初始化语句，B为条件表达式语句，C为后处理表达式语句。</p>
<p>A语句在整个循环开始前执行，可以是任意表达式语句，也可以是变量定义及初始化。</p>
<p>B为用作判断的表达式语句，在每次循环开始之前执行，当其值为真或为等价于真的值时才会进入循环，否则直接结束循环。</p>
<p>C为每次循环结束后的处理表达式，在每次循环后执行。</p>
<p>A、B、C中<strong>任意个语句可以为空</strong>，视情况而定。</p>
<h3 id="范围for循环"><a href="#范围for循环" class="headerlink" title="范围for循环"></a>范围for循环</h3><p>C++11提供的新特性，格式为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(declaration: expr)&#123; … &#125;<br></code></pre></td></tr></table></figure>
<p>其中expr必须是一个可迭代序列，如花括号括起来的列表、数组、vector等支持返回begin和end成员的容器等，其中declaration是一个用于迭代的临时变量，该变量<strong>要与要迭代的序列中的元素类型相容</strong>，最简单的办法是定义一个auto变量。</p>
<p>如果需要对序列中的元素进行写操作，要定义临时变量为<strong>引用</strong>类型。</p>
<p>使用for循环时都<strong>不应该增减序列中的元素</strong>，for循环更适合用来固定次数的循环。</p>
<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p>break语句将终止直接包含它的while、do while、for、switch语句，并从其后继续执行。</p>
<h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><p>用于<strong>循环</strong>，立即结束本次迭代并进入下一次迭代，不会直接终止循环。</p>
<p>for循环被continue的话，后处理语句还会照常进行的。</p>
<h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><p>无条件跳转语句。说是无条件，实际上还是有条件的：它只能在同一个函数中跳转，并和switch的case标签一样，不能跨变量定义跳转。</p>
<p>goto语句需要配合标签使用，标签是独立于其他标识符之外的名字，因此可以与其他标识符重名，只要标签之间互不重名就行。</p>
<h2 id="异常语句"><a href="#异常语句" class="headerlink" title="异常语句"></a>异常语句</h2><h3 id="捕捉异常"><a href="#捕捉异常" class="headerlink" title="捕捉异常"></a>捕捉异常</h3><p>通过try语句捕捉异常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">try</span> &#123;<br>    … <span class="hljs-comment">// 可能出现异常的语句</span><br>&#125;<br><span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (exception-declaration)&#123;<br>    …<br>&#125;<br><span class="hljs-built_in"><span class="hljs-keyword">catch</span></span>(exception-declaration)&#123;<br>    …<br>&#125; <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>

<p>将可能出现异常的语句放在try语句块中，如果执行正常那么什么也不会发生，就像没有try语句一样，而如果出现了异常，就会转入异常捕捉流程。</p>
<p>try语句后跟着<strong>一个或多个</strong>catch子句，catch子句括号中是异常声明，声明一个异常对象，并接收出现的该类异常，如runtime _error err，然后在catch子句中进行一些处理。</p>
<p>C++的异常类定义在四个标准库头文件中：</p>
<ul>
<li>exception头文件定义了最通用的异常类exception，它只报告异常的发生，不提供任何额外信息。</li>
<li>stdexcept头文件定义了几种常用的异常类。</li>
<li>new头文件定义了bad_alloc异常类型，这种类型将在后面介绍。</li>
<li>type_info头文件定义了bad_cast异常类型，这种类型也将在后面介绍。</li>
</ul>
<p>较为常用的是<strong>stdexcept</strong>头文件，其中定义的异常类有：</p>
<ul>
<li>exception：通用异常类。</li>
<li>runtime_error：只有在运行时才能检测出的问题。</li>
<li>range_error：运行时错误，生成的结果超出了有意义的值域范围。</li>
<li>overflow_error：运行时错误，计算上溢。</li>
<li>underflow_error：运行时错误，计算下溢。</li>
<li>logic_error：程序逻辑错误。</li>
<li>domain_error：逻辑错误，参数对应的结果值不存在。</li>
<li>invalid_argument：逻辑错误，无效参数。</li>
<li>length_error：逻辑错误，试图创建一个超出该类型最大长度的对象。</li>
<li>out_of_range：逻辑错误，使用一个超出有效范围的值。</li>
</ul>
<p>我们只能在catch子句的括号里以<strong>默认初始化</strong>的方式来定义这些类的对象，不能给它们提供初始值。</p>
<p>异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const char*，该字符串的目的是提供关于异常的一些文本信息。</p>
<p>what函数返回的C风格字符串的内容与异常对象的类型有关，如果异常类型有一个字符串初始值，则what返回该字符串，对于其他无初始值的异常类型来说，what返回的内容由编译器决定。</p>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>我们需要人为抛出异常时使用throw表达式，从而抛出一个异常对象，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span> ( <span class="hljs-string">&quot;Data must refer to same ISBN&quot;</span>);<br></code></pre></td></tr></table></figure>

      </section>
      <section class="extra">
        <!-- 
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>Dasen Sun</li>
    <li><strong>本文链接：</strong><a href="http://example.com/2021/07/28/cpp005/index.html" title="http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;07&#x2F;28&#x2F;cpp005&#x2F;index.html">http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;07&#x2F;28&#x2F;cpp005&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
         -->
        
          <br>
          <center><hr></center>
          <br>
          <center>* 你好，我是大森。如果文章内容帮到了你，你可通过下方付款二维码支持作者 *</center>
          <br>
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="/images/qrcode/alipay.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
          <center><hr></center>
          <br>
        
        
        
  <nav class="nav">
    <a href="/2021/08/09/cpp006/"><i class="iconfont iconleft"></i><i class="iconfont iconleft"></i> C++学习笔记（6）：函数</a>
    <a href="/2021/07/19/cpp004/">C++学习笔记（4）：数组及其抽象类型 <i class="iconfont iconright"></i><i class="iconfont iconright"></i></a>
  </nav>

      </section>
      <!--  -->
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A6%82%E5%BF%B5"><span class="toc-text">表达式概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E8%BF%90%E7%AE%97%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">表达式、运算对象和运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%81%E7%BB%93%E5%90%88%E5%BE%8B%E5%92%8C%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="toc-text">优先级、结合律和求值顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">递增递减运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">成员访问运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">强制类型转换运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">sizeof运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">其他运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8"><span class="toc-text">运算符优先级表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-text">语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%AD%E5%8F%A5"><span class="toc-text">简单语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E5%8F%A5"><span class="toc-text">表达式语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E8%AF%AD%E5%8F%A5"><span class="toc-text">空语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E8%AF%AD%E5%8F%A5"><span class="toc-text">复合语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">条件语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">if条件语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">switch条件语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-text">循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="toc-text">while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-while%E5%BE%AA%E7%8E%AF"><span class="toc-text">do-while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9Ffor%E5%BE%AA%E7%8E%AF"><span class="toc-text">传统for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4for%E5%BE%AA%E7%8E%AF"><span class="toc-text">范围for循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#break%E8%AF%AD%E5%8F%A5"><span class="toc-text">break语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#continue%E8%AF%AD%E5%8F%A5"><span class="toc-text">continue语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#goto%E8%AF%AD%E5%8F%A5"><span class="toc-text">goto语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%AF%AD%E5%8F%A5"><span class="toc-text">异常语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8"><span class="toc-text">捕捉异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-text">抛出异常</span></a></li></ol></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="https://www.instagram.com/zhangsiyu_2/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/sadose/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:sadose@qq.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  孙大森 - 2021</p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>