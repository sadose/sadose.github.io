

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>C++学习笔记（4）：数组及其抽象类型 - 大森的博客</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="数组数组的特点
数组是存放相同类型对象的容器，这些对象...">
  <meta name="author" content="Dasen Sun">
  <link rel="icon" href="/images/icons/logo-16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/logo-32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/logo-180.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/logo-144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_r673sha78lq.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '[object Object]'
      },
      donate: {
        enable: true,
        alipay: '/images/qrcode/alipay.jpg',
        wechat: '/images/qrcode/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '人生如逆旅，我亦是行人。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: '/images/qrcode/qrcode.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: false,
        path: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
    </div>
    <div class="center">C++学习笔记（4）：数组及其抽象类型</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>　
      </li><li class="menu-item">
        <a href="/categories/cpp/ " class="underline "> C++</a>　
      </li><li class="menu-item">
        <a href="/categories/frontend/ " class="underline "> HTML/CSS</a>　
      </li><li class="menu-item">
        <a href="/categories/other/ " class="underline "> 其他</a>　
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>　
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  孙大森 - 2021</p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/post/cpp.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">C++学习笔记（4）：数组及其抽象类型</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>July 19, 2021</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>10588</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组的特点"><a href="#数组的特点" class="headerlink" title="数组的特点"></a>数组的特点</h2><ul>
<li>数组是存放<strong>相同类型</strong>对象的容器，这些对象没有名字，需要通过其所在位置访问。</li>
<li>数组的<strong>大小固定不变</strong>，在定义时就为其开辟了固定的存储空间，因此不能随意向数组中添加元素，也不能缩减数组所占的存储空间。</li>
<li>因为数组的大小固定，所以<strong>损失了一部分灵活性</strong>，但<strong>性能相对来说更高</strong>。</li>
</ul>
<h2 id="数组的定义和初始化"><a href="#数组的定义和初始化" class="headerlink" title="数组的定义和初始化"></a>数组的定义和初始化</h2><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p>数组的定义方式如a[n]，其中a为数组名，n为数组中元素个数，因此n必须大于0。数组中元素的个数在编译的时候必须是已知的，因此n必须是一个<strong>常量表达式</strong>。如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure>
<p>合法，而</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string str[<span class="hljs-built_in">get_size</span>()];<br></code></pre></td></tr></table></figure>
<p>仅在函数get_size为constexpr函数时合法。</p>
<p>此外，定义数组时不允许使用auto关键字。</p>
<h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><p>和内置类型的变量一样，当定义了内置类型的数组时，其所有元素的值被<strong>默认初始化</strong>（即在全局作用域中所有元素为0，在函数作用域中函数值为无意义的随机值）。</p>
<p>除默认初始化外，数组支持手动初始化，具体方式为<strong>列表初始化</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure>
<p>如果使用列表初始化的方式，允许不提供数组的大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure>
<p>总而言之其实就是在编译时就要能够确定数组元素个数，无论是使用列表初始化还是用常量表达式指定元素个数，都是为了这一目的。</p>
<p>如果列表初始化时提供的值的个数与指定的数组元素个数不一致：</p>
<ul>
<li>初始化提供的值多了，不合法。</li>
<li>初始化提供的值少了，那么使用提供的值初始化数组前几个元素，其余元素依然使用默认初始化的方式。</li>
</ul>
<h3 id="字符串的初始化"><a href="#字符串的初始化" class="headerlink" title="字符串的初始化"></a>字符串的初始化</h3><p>对于普通的字符数组，只是普通数组中存放的对象都是字符罢了。而如果希望字符数组作为字符串来使用，那么必须要注意<strong>字符串结束符</strong>&#39;\0&#39;的存储。</p>
<p>如果使用列表初始化的方法初始化一个字符串，应当显式地指定结束符&#39;\0&#39;：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> str[] = &#123;<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br></code></pre></td></tr></table></figure>

<p>此外C++提供了更方便的初始化方式，这时不用显式地指定结束符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> str[] = <span class="hljs-string">&quot;C++&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>而在这样初始化时，一定要注意显式指定数组长度时要考虑到结束符，如下面这样就是错误的，没有<strong>给结束符预留空间</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> str[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;C++&quot;</span>;<br></code></pre></td></tr></table></figure>
<p>如果把长度改为大于或等于4的值，就可以编译通过。</p>
<h3 id="复杂的数组定义"><a href="#复杂的数组定义" class="headerlink" title="复杂的数组定义"></a>复杂的数组定义</h3><p>对于以下较难理解的复杂的数组定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *ptrs[<span class="hljs-number">10</span>];<br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*Parray)[<span class="hljs-number">10</span>] = &amp;arr;<br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (&amp;arrRef)[<span class="hljs-number">10</span>] = arr;<br><span class="hljs-keyword">int</span> *(&amp;arry)[<span class="hljs-number">10</span>] = ptrs;<br></code></pre></td></tr></table></figure>

<p>ptrs是一个有10个元素的整型指针构成的数组（指针的数组），而Parray是一个指向具有十个整型元素的数组的指针（数组的指针）。</p>
<p>对于后两个，可以使用从内向外解读的方法，&amp;arrRef代表arrRef是个引用，而后面[10]代表了引用的是具有10个整型元素的数组；&amp;arry代表arry是个引用，引用的也是10个元素的数组，但是数组元素的类型为整型指针，也就是int *。</p>
<h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>访问数组元素通过<strong>下标</strong>来实现，一个具有n个元素的数组，其下标范围为0~n-1。</p>
<p>我们通常可以定义一个int i作为下标搭配for循环来用于迭代数组，而另一种做法为定义一个<strong>size_t类型</strong>的变量作为下标用于迭代数组，size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，使用时需要引用该头文件。</p>
<p>对于C++11标准，有更加简洁的遍历数组的方式，也就是范围for语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : scores)<br>    cout&lt;&lt; i &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt;endl;<br></code></pre></td></tr></table></figure>
<p>这样的话当仅仅是使用数组元素时，我们就不用过多关心下标是否越界了，不需要主动地控制下标。</p>
<h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><h3 id="数组与指针的关系"><a href="#数组与指针的关系" class="headerlink" title="数组与指针的关系"></a>数组与指针的关系</h3><p>对数组的元素使用取地址运算符可得到该数组元素的地址，而数组名本身即为数组首元素的地址，即<strong>使用数组名即为使用该数组对象的首地址</strong>。</p>
<p>因此在一些时候，对数组对象的操作实际上是指针的操作，如使用auto推断的时候：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">auto</span> ap = a;<br></code></pre></td></tr></table></figure>
<p>此时推断得到的ap类型为int *，即整型指针。</p>
<h3 id="使用指针迭代数组元素"><a href="#使用指针迭代数组元素" class="headerlink" title="使用指针迭代数组元素"></a>使用指针迭代数组元素</h3><p>由于数组a的名字就代表了数组首元素的地址，因此可以使用数组名称a进行指针自增自减运算来遍历数组元素，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">int</span> *e = &amp;a[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> *b = a; b != e; ++b)<br>    cout &lt;&lt; *b &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p>可以看到这样来进行边界控制较为麻烦，实际上C++11标准提供了获取数组首尾元素地址的解决方案：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">int</span> *e = <span class="hljs-built_in">end</span>(a), *b = <span class="hljs-built_in">begin</span>(a) ;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> *i = b; i != e; ++i)<br>    cout &lt;&lt; *i &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p>对于指针来说，其运算类型比较有限，常用的有：</p>
<ul>
<li>解引用，运算结果是引用的对象。</li>
<li>递增递减，运算结果是指针。</li>
<li>与整数相加，运算结果是指针。</li>
<li>两指针相减，运算结果是ptrdiff_t，实质是一种带符号整数，定义在cstddef标准库。</li>
</ul>
<h3 id="下标运算的实质"><a href="#下标运算的实质" class="headerlink" title="下标运算的实质"></a>下标运算的实质</h3><p>我们常常可以看到使用下标运算的方式来访问数组元素，如a[3]，但对于下标运算的实现原理实际是指针的数加和解引用运算，即a[i]将被展开成为*(a+i)，从而实现访问对应元素的操作。</p>
<p>有趣的是，我们利用这一原理，将a[3]写成3[a]也是合法的，即a[3]等价于3[a]，在编译器中完全能够编译通过并不会出现问题，原因就在于3[a]会被展开为*(3+a)，这与*(a+3)显然是等价的。</p>
<p>因此，下标运算实际上是<strong>支持负数下标</strong>的，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">int</span> *p = &amp;a[<span class="hljs-number">2</span>];<br>cout  &lt;&lt;  p[<span class="hljs-number">-2</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>此时输出的值为1，也就是p[-2]等价于*(p-2)，即a[0]。</p>
<p>以上特性（负数下标）<strong>只适用于内置数组</strong>，标准库中的其他容器并不适用。</p>
<h3 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h3><p>C风格字符串就是将字符串存储在数组中，并以结束符&#39;\0&#39;结尾的字符串，它们本质就是字符数组，因此使用起来有诸多不便，对它们的操作一般需要cstring标准库中提供的函数来进行，<strong>这些函数并不对传入的字符串的合法性作检查</strong>，需要我们自己来维护，这样有很多不方便的地方。</p>
<p>C++提供了string对象来作为字符串使用，它实际上是基于数组的抽象封装，使用起来更加方便灵活。</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>严格地来说，C++并没有提供多维数组，所谓的多维数组，其实是<strong>数组的数组</strong>。</p>
<p>多维数组在初始化时可以使用<strong>分层嵌套的列表</strong>，或者<strong>一维列表</strong>，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]= &#123;<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>    &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;,<br>    &#123;<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>就是使用分层嵌套的列表来初始化二维数组，这样看起来层次分明、容易读懂，而</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]= &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span> &#125;;<br></code></pre></td></tr></table></figure>
<p>也是可以完成初始化的，因为虽然多维数组在逻辑上是多维的，但在存储结构中仍然是线性存储的。</p>
<p>此外，多层嵌套的列表可以做到只初始化每行的一部分值，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]= &#123; &#123; <span class="hljs-number">0</span> &#125;, &#123; <span class="hljs-number">4</span> &#125;, &#123; <span class="hljs-number">8</span> &#125; &#125;;<br></code></pre></td></tr></table></figure>
<p>没有了嵌套的括号则相当于只初始化了第一行（前几个值）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]= &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span> &#125;;<br></code></pre></td></tr></table></figure>
<p>其他的元素使用默认初始化的方式进行默认初始化。</p>
<p>在使用多维数组下标时，只需要牢记多维数组就是数组的数组就行了，而对于较为复杂的定义，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (&amp;row)[<span class="hljs-number">4</span>] = ia[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure>
<p>要像之前理解复杂的指针、引用定义一样由内而外地理解这条定义。也就是定义了一个变量row，首先这个变量是一个引用，然后它是一个四个元素数组的引用，ia是包含了三个长度为4的数组的数组，然后把row绑定到了ia的第一个数组上。</p>
<p>使用范围for循环访问多维数组也是一样的，把多维数组当成数组的数组就可以了，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">size_t</span> cnt = <span class="hljs-number">0</span> ;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;row : ia)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;col : row)&#123;<br>        col = cnt;<br>    ++cnt;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中我们使用引用是因为我们要写数组元素，那么当我们不需要写数组元素的时候，还是要把<strong>除了最内层的临时变量以外的临时变量定义成引用</strong>，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;row : ia)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> col : row)<br>        cout &lt;&lt; col &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>原因是如果不定义为引用，那么auto推断出的类型会是指针，那么下一层的范围for就无法使用了。当直接使用多维数组的名字时，它也会被视为指针。但是要注意，除非指针指向最内层元素，否则定义指针时必须要注意<strong>指向的数组的形状</strong>，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*p)[<span class="hljs-number">4</span>] = ia;<br>&amp;ia[<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure>
<p>这里的指针p要定义为指向长度为4的数组的指针，因为对于二维数组来说，它的第一个元素是一个长度为4的数组，假如是一维数组，它的第一个元素就是一个int，因此不必考虑形状——也就是数组名字代表的指针指向它的第一个元素；指针本身隐含了指向的对象的长度信息，这样自增自减、数加类的指针运算才能正确使用。</p>
<p>使用指针来迭代多维数组的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = ia; p != ia + <span class="hljs-number">3</span>; ++p）&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> q = *p; q != *p +<span class="hljs-number">4</span>; ++q)<br>        cout&lt;&lt; *q&lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此外，想要简化数组类型的表示还可以使用<strong>类型别名</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> int_array = <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>];<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> int_array[<span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure>

<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="vector简介"><a href="#vector简介" class="headerlink" title="vector简介"></a>vector简介</h2><p>vector用于表示对象的集合，它本身也是个对象，因此vector也是容器。</p>
<p>vector与数组相同的地方有：</p>
<ul>
<li>它们所能容纳的对象都必须是同一类型的。</li>
<li>每个对象都需要通过索引访问。</li>
</ul>
<p>vector与数组有区别的地方是：</p>
<ul>
<li>数组是内置的，vector需要引入标准库头文件才可以使用。</li>
<li>vector是通过类模板实现的。</li>
<li>数组长度固定，操作不方便，使用复杂，vector长度可变，可以随意添加删除元素，并且有丰富的方法和函数对其进行操作。</li>
</ul>
<h2 id="vector的定义"><a href="#vector的定义" class="headerlink" title="vector的定义"></a>vector的定义</h2><p>首先，使用vector要先引入头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>由于vector是通过模板类来实现的，因此需要使用模板类的定义方式来定义一个vector，即需要在类名称后<strong>使用尖括号提供类型名称</strong>，来定义vector对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt; ivec;<br>vector&lt;Sales_item&gt; sales_vec;<br>vector&lt;vector&lt;string&gt;&gt; file;<br></code></pre></td></tr></table></figure>
<p>其中最后一个例子定义了一个嵌套的vector，即file作为一个vector其存放的元素都是vector&lt;string&gt;对象。</p>
<p>vector是模板类而不是类型，因此一定要带有尖括号提供实例化的参数类型才能当类使用。</p>
<p>需要注意的是在早期C++标准中嵌套的vector定义时与C++11有所不同，在新标准中可以使用上例中的定义方式，而在早期标准中，定义类型时最后两个右尖括号中间要有一个空格，即：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;string&gt; &gt; file;<br></code></pre></td></tr></table></figure>

<h2 id="初始化vector"><a href="#初始化vector" class="headerlink" title="初始化vector"></a>初始化vector</h2><p>模板类规定了它本身的初始化方式，vector的初始化方式主要有以下几种：</p>
<ul>
<li>vector&lt;T&gt; v1：默认初始化，v1是一个指定类型的空vector。</li>
<li>vector&lt;T&gt; v2(v1)：v2中包含有v1所有元素的副本。</li>
<li>vector&lt;T&gt; v2 = v1：等价于v2(v1)，v2中包含有v1所有元素的副本。</li>
<li>vector&lt;T&gt; v3(n, val)：v3包含了n个重复的元素，每个元素的值都是val。</li>
<li>vector&lt;T&gt; v4(n)：v4包含了n个重复地执行了值初始化的对象。</li>
<li>vector&lt;T&gt; v5{a,b,c…}：v5包含了初始值个数的元素，每个元素被赋予相应的初始值。</li>
<li>vector&lt;T&gt; v5 = {a,b,c…}：等价于v5{a,b,c…}。</li>
<li>vector&lt;T&gt; v6(begin(arr),end(arr))：使用数组初始化vector，只需提供数组的首地址和尾后地址。</li>
</ul>
<p>最常见的方式就是先定义一个空vector，然后当运行时获取到元素的值后再逐一添加。</p>
<p>在使用一个vector来初始化另一个vector时，它们中的元素类型必须相同。</p>
<p>第五种初始化方式只提供了vector内元素的数量而没有指定值，这时采用的是<strong>值初始化</strong>的方式，而不是默认初始化的方式，默认初始化得到的值是随机的，值初始化则是固定的初始值：</p>
<ul>
<li>当vector内元素为内置类型时，值初始化为0。</li>
<li>当vector内元素为其他对象时，调用该对象所属类规定的默认初始化方法，但是当该类型不支持默认初始化时，这种方法就不能用了。</li>
</ul>
<p>此外，当使用列表初始化失败时，编译器会尝试将列表中提供的值作为参数来初始化，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; v1&#123;<span class="hljs-string">&quot;hi&quot;</span>&#125;;<br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-string">&quot;hi&quot;</span>)</span></span>;<br>vector&lt;string&gt; v3&#123;<span class="hljs-number">10</span>&#125;;<br>vector&lt;string&gt; v4&#123;<span class="hljs-number">10</span>, <span class="hljs-string">&quot;hi&quot;</span>&#125;;<br>vector&lt;string&gt; v5&#123;v1&#125;;<br></code></pre></td></tr></table></figure>
<p>中v2是非法的，v1成功执行了列表初始化，v3和v4、v5列表初始化没有成功但是将列表内的值作为初始化参数进行初始化成功了，它们其实等价于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">v4</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;hi&quot;</span>)</span></span>;<br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">v5</span><span class="hljs-params">(v1)</span></span>;<br></code></pre></td></tr></table></figure>

<h2 id="向vector中添加对象"><a href="#向vector中添加对象" class="headerlink" title="向vector中添加对象"></a>向vector中添加对象</h2><h3 id="向尾端添加元素"><a href="#向尾端添加元素" class="headerlink" title="向尾端添加元素"></a>向尾端添加元素</h3><p>对于vector对象，我们可以使用<strong>push_back成员函数</strong>将一个对象加入到vector的末尾，这时的vector就可以像一个栈一样使用。</p>
<p>在实际使用时我们往往就是创建一个空的vector，再通过这样的方法将需要的对象插入到其中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt; v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">100</span>; ++i)<br>    v2.<span class="hljs-built_in">push_back</span>(i);<br></code></pre></td></tr></table></figure>

<h3 id="对vector添加元素时的注意事项"><a href="#对vector添加元素时的注意事项" class="headerlink" title="对vector添加元素时的注意事项"></a>对vector添加元素时的注意事项</h3><ul>
<li>由于vector在定义时不显式地指定初始值列表，而是通常使用一个for循环来将值依次插入vector，因此要求在编程时所写的循环准确无误，尤其是vector的大小可能被改变时，使用循环来操作vector很容易出现逻辑错误。</li>
<li>如果在循环体内有添加元素的操作时，不能使用范围for循环，或者说<strong>在范围for循环中不应改变其所遍历的序列的大小</strong>。</li>
</ul>
<h2 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h2><h3 id="检查vector的尺寸"><a href="#检查vector的尺寸" class="headerlink" title="检查vector的尺寸"></a>检查vector的尺寸</h3><p>与vector尺寸有关的两个成员函数主要为empty和size：</p>
<p>empty检查vector对象是否包含元素然后返回一个布尔值；size则返回vector对象中元素的个数，返回值的类型是由vector定义的size_type类型，它实际上是个无符号的整型（注意区别数组下标）。</p>
<p>要使用size_type，需首先指定它是由哪种类型定义的，vector对象的类型总是包含着元素的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt;::size_type<br></code></pre></td></tr></table></figure>

<h3 id="vector的比较"><a href="#vector的比较" class="headerlink" title="vector的比较"></a>vector的比较</h3><p>两个vector对象相等的条件是：两个vector的长度相等并且对应位置上的元素也相等。</p>
<p>两个vector进行比较是按照<strong>字典序</strong>比较的：</p>
<ul>
<li>如果一个vector1的所有元素与另一个vector2的前一部分元素完全相同，且1和2的长度不同（即1比2短），那么vector1&lt;vector2。</li>
<li>如果两个vector在同一位置有不同的元素，那么它们的大小取决于它们第一对不同元素的大小。</li>
</ul>
<p>此外，vector的比较还包含了一个隐含的条件：vector中的元素能够比较时，vector才能比较。</p>
<h3 id="vector的下标运算"><a href="#vector的下标运算" class="headerlink" title="vector的下标运算"></a>vector的下标运算</h3><p>和数组一样，vector的下标从0开始，可以直接通过下标来访问对应位置上的元素或赋值，下标的数据类型也是对应元素类型的size_type类型。</p>
<p>在使用下标时要保证不能下标越界。</p>
<p>此外，不能使用下标形式添加元素。</p>
<h3 id="对vector赋值"><a href="#对vector赋值" class="headerlink" title="对vector赋值"></a>对vector赋值</h3><p>用v2中元素的拷贝替换v1中的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">v1 = v2;<br></code></pre></td></tr></table></figure>
<p>用列表中元素的拷贝替换v1中的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">v1 = &#123;a, b, c, ……&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="使用string"><a href="#使用string" class="headerlink" title="使用string"></a>使用string</h2><p>标准库类型string表示<strong>可变长的字符序列</strong>，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。</p>
<p>对string的初始化主要有以下几种类型：</p>
<ul>
<li>string s1：默认初始化，s1是一个空串。</li>
<li>string s2(s1)：s2是s1的副本。</li>
<li>string s2 = s1：等价于s2(s1)，s2是s1的副本。</li>
<li>string s3 (&quot;value&quot;)：s3是字面值&quot;value&quot;的副本，除了字面值最后的那个空字符外。</li>
<li>string s3 = &quot;value&quot;：等价于s3 (&quot;value&quot;)，s3是字面值&quot;value&quot;的副本。</li>
<li>string s4(n,&#39;c&#39;)：把s4初始化为由连续n个字符c组成的串。</li>
</ul>
<p>使用等号的是拷贝初始化，不使用等号的是直接初始化。</p>
<h2 id="string操作"><a href="#string操作" class="headerlink" title="string操作"></a>string操作</h2><p>与vector相同的操作：</p>
<ul>
<li>检查string的长度：size和empty成员函数。</li>
<li>索引访问、赋值。</li>
<li>拷贝副本。</li>
<li>两个字符串比较。</li>
</ul>
<p>string独有的操作：</p>
<ul>
<li>getline(is, s)：从输入流is中读取一行赋给s，返回is。</li>
<li>s1+s2：字符串连接，返回连接后的结果，此外+=运算符也是支持的。</li>
</ul>
<p>注意：使用getline函数读入字符串时将读取一行，遇到换行符停止；而使用cin读取时，和C语言中使用scanf一样，遇到空白符停止。其中换行符和空白符均不会被读入。此外，使用cin读取时，开头的空白符也会被忽略，就像对字符串使用了strip一样。</p>
<p>和vector一样，string的size成员函数返回的类型也是对应的size_type类型，即string::size_type。</p>
<p>字符串相加时可以让string和字面值相加，但不能让字面值和字面值相加。</p>
<h2 id="处理string中的字符"><a href="#处理string中的字符" class="headerlink" title="处理string中的字符"></a>处理string中的字符</h2><h3 id="判断字符的类别"><a href="#判断字符的类别" class="headerlink" title="判断字符的类别"></a>判断字符的类别</h3><p>cctype头文件提供了一系列判断和处理字符类别的函数，主要有：</p>
<ul>
<li>isalnum(c)：当c是字母或数字时为真。</li>
<li>isalpha(c)：当c是字母时为真。</li>
<li>iscntrl(c)：当c是控制字符时为真。</li>
<li>isdigit(c)：当c是数字时为真。</li>
<li>isgraph(c)：当c不是空格但可打印时为真。</li>
<li>islower(c)：当c是小写字母时为真。</li>
<li>isprint(c)：当c是可打印字符时为真（即c是空格或c具有可视形式）。</li>
<li>ispunct(c)：当c是标点符号时为真（即c不是控制字符、数字、字母、可打印空白中的一种）。</li>
<li>isspace (c)：当c是空白时为真（即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种）。</li>
<li>isupper(c)：当c是大写字母时为真。</li>
<li>isxdigit(c)：当c是十六进制数字时为真。</li>
<li>tolower(c)：如果c是大写字母，输出对应的小写字母，否则原样输出c。</li>
<li>toupper(c)：如果c是小写字母，输出对应的大写字母，否则原样输出c。</li>
</ul>
<h3 id="迭代string中的字符"><a href="#迭代string中的字符" class="headerlink" title="迭代string中的字符"></a>迭代string中的字符</h3><p>通常情况下，使用范围for语句来迭代string中的字符是很方便的，但是如果需要改变字符的值，在使用范围for语句时需要将临时变量定义为引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">s</span> <span class="hljs-params">(<span class="hljs-string">&quot;Hello World! !!&quot;</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : s)<br>    c = <span class="hljs-built_in">toupper</span>(c);<br>cout &lt;&lt; s &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>而当只需要处理字符串中的一部分字符时，使用下标来访问或者使用迭代器是更好的选择。使用下标访问的时候同样需要注意控制边界。</p>
<h3 id="混用string对象与C风格字符串"><a href="#混用string对象与C风格字符串" class="headerlink" title="混用string对象与C风格字符串"></a>混用string对象与C风格字符串</h3><p>实际上字符串字面值也是C风格字符串，在编译程序时，编译器会为字面值开辟一个大小恰好合适的字符数组（临时区域）来存放这个字符串，并且该字面值实际上是这个字符数组的首地址。</p>
<p>（1）为了能从一个C风格字符串得到string对象，允许使用C风格字符串来初始化string对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">s</span> <span class="hljs-params">(<span class="hljs-string">&quot;Hello World&quot;</span> )</span></span>;<br></code></pre></td></tr></table></figure>

<p>（2）为了能从string对象中得到其对应的字符数组，string提供了成员函数c_str：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str = s.<span class="hljs-built_in">c_str</span>();<br></code></pre></td></tr></table></figure>

<p>（3）允许string与C风格字符串进行相加（连接）。</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h2><p>由于容器是一个经过了封装的对象，因此无法使用指针。类比使用指针迭代数组，标准库提供了使用迭代器，可以像使用指针一样来迭代容器对象。所有的标准库容器都支持迭代器。</p>
<p>我们知道，通过begin和end函数可以获得数组的首指针和尾后指针，而通过容器对象的begin和end方法，也可以得到该容器的首迭代器和尾后迭代器。</p>
<p>以vector来举例：vector的迭代器的类型应当是vector&lt;T&gt;::iterator，因此我们可以这样来定义迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;<br>string::iterator it2;<br></code></pre></td></tr></table></figure>

<p>除了iterator之外，还有const_iterator类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator it3;<br>string::const_iterator it4;<br></code></pre></td></tr></table></figure>
<p>就像常量指针一样，const_iterator是常量迭代器，它指向的对象是<strong>只读的</strong>，不可以修改，而iterator对象指向的对象可读也可写。与const_iterator配套的成员函数cbegin和cend返回的是常量迭代器。</p>
<p>就像使用指针一样，迭代器也可以用*来解引用得到其指向的对象，同时也可使用自增自减运算符来移动迭代器指向的位置，这样就可以实现对容器的迭代：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>() &amp;&amp; !<span class="hljs-built_in">isspace</span>(*it); ++it)<br>    *it= <span class="hljs-built_in">toupper</span>(*it); <br></code></pre></td></tr></table></figure>
<p>对于迭代器指向的对象，要想使用其成员变量或成员函数，可以像使用指针一样使用指针成员访问运算符（-&gt;）。</p>
<h2 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h2><h3 id="自增自减运算"><a href="#自增自减运算" class="headerlink" title="自增自减运算"></a>自增自减运算</h3><p>可以通过自增运算符++和自减运算符–来推移迭代器的位置，每次移向上一个元素或下一个元素。</p>
<h3 id="数加运算"><a href="#数加运算" class="headerlink" title="数加运算"></a>数加运算</h3><p>自增自减运算符一次只能推移一个位置，而数加运算一次可以推移多个位置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">it = it + n;<br>it = it - n;<br></code></pre></td></tr></table></figure>
<p>其中n为整数。当然也可以表示为以下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">it += n;<br>it -= n;<br></code></pre></td></tr></table></figure>

<h3 id="相减运算"><a href="#相减运算" class="headerlink" title="相减运算"></a>相减运算</h3><p>可以计算两个迭代器相差的元素个数，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">n = it1 - it2;<br></code></pre></td></tr></table></figure>

<p>在此基础上可以实现迭代器的算术运算，如在二分查找时常常能够这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> beg = text.<span class="hljs-built_in">begin</span>() , end = text.<span class="hljs-built_in">end</span> () ;<br><span class="hljs-keyword">auto</span> mid = text.<span class="hljs-built_in">begin</span> () + (end - beg)/<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>

<h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><p>两个对同一对象的迭代器可以进行比较，支持的比较运算有&gt;、&gt;=、&lt;、&lt;=、==、!=等。</p>
<p>通过比较运算可以实现边界的判断等。</p>
<p>如果一个容器对象为空，那么它的首迭代器和尾后迭代器是相等的。</p>

      </section>
      <section class="extra">
        <!-- 
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>Dasen Sun</li>
    <li><strong>本文链接：</strong><a href="http://example.com/2021/07/19/cpp004/index.html" title="http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;07&#x2F;19&#x2F;cpp004&#x2F;index.html">http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;07&#x2F;19&#x2F;cpp004&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
         -->
        
          <br>
          <center><hr></center>
          <br>
          <center>* 你好，我是大森。如果文章内容帮到了你，你可通过下方付款二维码支持作者 *</center>
          <br>
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="/images/qrcode/alipay.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
          <center><hr></center>
          <br>
        
        
        
  <nav class="nav">
    <a href="/2021/07/28/cpp005/"><i class="iconfont iconleft"></i><i class="iconfont iconleft"></i> C++学习笔记（5）：语句和表达式</a>
    <a href="/2021/07/06/cpp003/">C++学习笔记（3）：类型与变量 <i class="iconfont iconright"></i><i class="iconfont iconright"></i></a>
  </nav>

      </section>
      <!--  -->
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">数组的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">数组的定义和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">数组的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">数组的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">字符串的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89"><span class="toc-text">复杂的数组定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text">访问数组元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-text">指针和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">数组与指针的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E8%BF%AD%E4%BB%A3%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text">使用指针迭代数组元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%9A%84%E5%AE%9E%E8%B4%A8"><span class="toc-text">下标运算的实质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">C风格字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">多维数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vector"><span class="toc-text">vector</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E7%AE%80%E4%BB%8B"><span class="toc-text">vector简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">vector的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96vector"><span class="toc-text">初始化vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91vector%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%AF%B9%E8%B1%A1"><span class="toc-text">向vector中添加对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E5%B0%BE%E7%AB%AF%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text">向尾端添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9vector%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">对vector添加元素时的注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96vector%E6%93%8D%E4%BD%9C"><span class="toc-text">其他vector操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5vector%E7%9A%84%E5%B0%BA%E5%AF%B8"><span class="toc-text">检查vector的尺寸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">vector的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E7%9A%84%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97"><span class="toc-text">vector的下标运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9vector%E8%B5%8B%E5%80%BC"><span class="toc-text">对vector赋值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#string"><span class="toc-text">string</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8string"><span class="toc-text">使用string</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E6%93%8D%E4%BD%9C"><span class="toc-text">string操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86string%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-text">处理string中的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="toc-text">判断字符的类别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3string%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-text">迭代string中的字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E7%94%A8string%E5%AF%B9%E8%B1%A1%E4%B8%8EC%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">混用string对象与C风格字符串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">使用迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%90%E7%AE%97"><span class="toc-text">迭代器运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97"><span class="toc-text">自增自减运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%8A%A0%E8%BF%90%E7%AE%97"><span class="toc-text">数加运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%87%8F%E8%BF%90%E7%AE%97"><span class="toc-text">相减运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97"><span class="toc-text">比较运算</span></a></li></ol></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="https://www.instagram.com/zhangsiyu_2/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/sadose/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:sadose@qq.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  孙大森 - 2021</p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>