

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>JavaScript学习笔记（1）：语言基础 - 大森的博客</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="基本语法标识符作为变量、函数、属性或参数的名称。
规则...">
  <meta name="author" content="Dasen Sun">
  <link rel="icon" href="/images/icons/logo-16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/logo-32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/logo-180.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/logo-144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_r673sha78lq.css">

  

  
    
<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '[object Object]'
      },
      donate: {
        enable: true,
        alipay: '/images/qrcode/alipay.jpg',
        wechat: '/images/qrcode/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '人生如逆旅，我亦是行人。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: '/images/qrcode/qrcode.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: false,
        path: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
    </div>
    <div class="center">JavaScript学习笔记（1）：语言基础</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>　
      </li><li class="menu-item">
        <a href="/categories/cpp/ " class="underline "> C++</a>　
      </li><li class="menu-item">
        <a href="/categories/frontend/ " class="underline "> HTML/CSS</a>　
      </li><li class="menu-item">
        <a href="/categories/js/ " class="underline "> JavaScript</a>　
      </li><li class="menu-item">
        <a href="/categories/notes/ " class="underline "> 课程笔记</a>　
      </li><li class="menu-item">
        <a href="/categories/tools/ " class="underline "> 工具</a>　
      </li><li class="menu-item">
        <a href="/categories/other/ " class="underline "> 其他</a>　
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>　
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  孙大森 - 2021</p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/post/js.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">JavaScript学习笔记（1）：语言基础</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>December 04, 2021</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>14228</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>作为变量、函数、属性或参数的名称。</p>
<p>规则：</p>
<ul>
<li>区分大小写；</li>
<li>第一个字符只能是字母、下划线(_)或美元符号($)；</li>
<li>其余字符还可以是数字；</li>
<li>上述“字母”不只是英文字母，可以是扩展ASCII字符和Unicode字符（但不推荐）。</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>单行注释：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 单行注释</span><br></code></pre></td></tr></table></figure>

<p>多行注释：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 多行</span><br><span class="hljs-comment">注释 */</span><br></code></pre></td></tr></table></figure>

<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>严格模式是ES5添加的一种执行模式，ES3的一些不规范的写法在这种模式下会被处理，对于不安全的操作将会<strong>抛出错误</strong>。启用严格模式就在脚本开头加上一个裸的字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&quot;use strict&quot;</span><br></code></pre></td></tr></table></figure>

<p>也可以单独指定一个函数使用严格模式执行，只需要在函数作用域开头加上这个字符串。</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>语句建议以分号结尾，虽然不加分号在绝大多数情况下也不会有任何问题。</p>
<p>像if之类的语句后跟的语句内容如果只有一行语句，可以不写成语句块，但是建议写成语句块。</p>
<h2 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h2><p>关键字是有特殊用途的标识符，不能用来当作变量或函数等名称的。ES5关键字有：</p>
<ul>
<li>break</li>
<li>do</li>
<li>in</li>
<li>typeof</li>
<li>case</li>
<li>else</li>
<li>instanceof</li>
<li>var</li>
<li>catch</li>
<li>export</li>
<li>new</li>
<li>void</li>
<li>class</li>
<li>extends</li>
<li>return</li>
<li>while</li>
<li>const</li>
<li>finally</li>
<li>super</li>
<li>with</li>
<li>continue</li>
<li>for</li>
<li>switch</li>
<li>yield</li>
<li>debugger</li>
<li>function</li>
<li>this</li>
<li>default</li>
<li>if</li>
<li>throw</li>
<li>delete</li>
<li>import</li>
<li>try</li>
</ul>
<p>保留字是ES标准为将来可能支持的功能保留的关键字，这些关键字也不要作为变量或函数的标识符来用。ES5规定的保留字有：</p>
<ul>
<li>始终保留：<ul>
<li>enum</li>
</ul>
</li>
<li>严格模式下保留：<ul>
<li>implements</li>
<li>package</li>
<li>public</li>
<li>interface</li>
<li>protected</li>
<li>static</li>
<li>let</li>
<li>private</li>
</ul>
</li>
<li>模块代码中保留：<ul>
<li>await</li>
</ul>
</li>
</ul>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>JS变量是<strong>弱类型</strong>的，变量只是个名称，它可以用于保存任意类型的数据。声明变量有var、let、const三种方式，其中let和const在ES6开始才可以使用，是ES6标准新增的内容。</p>
<p>变量应当在声明时初始化，或者确保会在之后使用它之前让它拥有一个可用的值，否则<strong>未经初始化的变量值都是undefined</strong>。</p>
<h2 id="var声明"><a href="#var声明" class="headerlink" title="var声明"></a>var声明</h2><p>var的作用域是<strong>函数作用域</strong>，也就是说只有函数作用域（和全局作用域）能够关住var声明的变量，函数内使用var声明的变量无法在函数外使用。</p>
<p>全局作用域内声明的var变量<strong>会成为window的属性</strong>。</p>
<p>var声明的变量会进行<strong>变量提升</strong>，所谓提升实际就是默认把声明拉到函数作用域（全局作用域）的顶部，也就是无论你在哪里第一次声明一个变量，都好像是在函数作用域的开始声明的一样。声明提升的特点有：</p>
<ul>
<li>无论在哪里的声明都会提升到函数作用域顶部，也就是在声明之前使用它不会报错，但是赋值的行为还是在原来的代码位置，因此在声明之前使用它虽然不会报错，但是它的值是undefined；</li>
<li>多次声明一个变量没有问题，如果每次赋值都初始化了值，都把它们当成普通的赋值语句来处理。</li>
</ul>
<p>有以下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;aaa&quot;</span>;<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// aaa</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;bbb&quot;</span><br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// bbb</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a); <span class="hljs-comment">// bbb</span><br></code></pre></td></tr></table></figure>

<h2 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h2><p>let声明和var的区别有：</p>
<ul>
<li>let声明的作用域是<strong>块作用域</strong>，块作用域就可以关住let声明；</li>
<li>let声明<strong>不会被提升</strong>；</li>
<li>在全局作用域使用let声明的变量不会成为window对象的属性。</li>
</ul>
<p>有以下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;aaa&quot;</span>;<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-string">&quot;bbb&quot;</span>;<br>    <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// aaa</span><br>    <span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// bbb</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// aaa</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// ReferenceError: b is not defined</span><br></code></pre></td></tr></table></figure>
<p>可以看到块作用域中的var变量可以被外面访问，let就不行。</p>
<p>有以下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// ReferenceError: b is not defined</span><br><span class="hljs-keyword">var</span> a;<br><span class="hljs-keyword">let</span> b;<br></code></pre></td></tr></table></figure>
<p>可以看出let变量声明不会被提升，当然也<strong>不能重复定义</strong>。在let变量声明前的区域被称为<strong>暂时性死区</strong>。</p>
<p>在没有let声明时，for循环中的var声明会渗透到循环外，因为for循环的块作用域关不住var声明，比如这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(i), <span class="hljs-number">0</span>)<br>&#125; <span class="hljs-comment">// 5 5 5 5 5</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; ++j) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(j), <span class="hljs-number">0</span>)<br>&#125; <span class="hljs-comment">// 0 1 2 3 4</span><br></code></pre></td></tr></table></figure>

<p>每次循环会往任务队列推一个延迟打印的任务，使用var循环的话循环完了，i也变成了5，延迟打印任务打印的全是5，而let的行为就好像是为每次循环创建了一个新的j，使得每次打印的值都不同。</p>
<h2 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h2><p>const变量和let大部分行为都相同，唯一不同的就是它<strong>必须在声明时初始化</strong>，因为稍后就无法修改它的值了，唯一给它赋值的机会就是初始化它的时候。</p>
<p>如果它指向引用值，那么这个引用的对象的内容还是可以修改的，只是它不能再引用别的对象了。</p>
<p>const变量适合用于for循环，用于迭代一个不准备改变的量。</p>
<h2 id="无声明"><a href="#无声明" class="headerlink" title="无声明"></a>无声明</h2><p>无声明的变量就是不使用关键字直接使用的变量，这样的变量直接就成为全局变量了，无论在哪里直接用，哪怕是在函数内直接拿来赋值，也会直接成为全局的变量，这样的行为是不推荐的。</p>
<p>为了规范代码，在使用时能够用const就不用let，能用let就不用var，而无声明的全局变量最好永远不要用。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h2><p>JS有七种简单数据类型（原始类型）：</p>
<ul>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Symbol</li>
<li>BigInt</li>
</ul>
<p>其中Symbol（符号类型）是ES6新增的，BigInt（大整数类型）是ES10新增的。</p>
<h3 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h3><p>只有一个可能的值，即undefined。</p>
<p>它会被解释为一个假值，因此在使用判断检测时要想好自己是否只希望检测undefined值，不要把其他假值错当成了undefined。</p>
<p>变量声明了但没赋值就会默认是这个值，但注意：</p>
<ul>
<li>未声明的变量和声明了但未赋值的变量是不同的，前者使用会报错，后者使用不会报错只是值为undefined；</li>
<li>未声明的变量和声明了但未赋值的变量在使用typeof测试时都会返回<code>&quot;undefined&quot;</code>。</li>
</ul>
<p>如以下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> b); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// ReferenceError: b is not defined</span><br></code></pre></td></tr></table></figure>

<h3 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h3><p>它也只有一个可能的值null，也是个假值，表示一个空的对象指针。如果在初始化一个未来用来保存对象的变量时，建议使用null初始化。</p>
<h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><p>有两个可能的值：true和false。</p>
<p>Boolean()函数用于将其他值转换为布尔值，规则如下：</p>
<ul>
<li>布尔值：原样返回。</li>
<li>字符串：空字符串转为false，其他为true。</li>
<li>数值：0和NaN转为false，其他为true（包括无穷值）。</li>
<li>对象：null转为fasle，其他任意对象都会为true。</li>
<li>undefined：始终为false。</li>
</ul>
<h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><p>Number类型使用IEEE754标准来保存整数和小数。</p>
<p>字面量：</p>
<ul>
<li>十进制整数：直接书写；</li>
<li>八进制整数：（严格模式下不支持八进制）以0开头，但如果任意位数上出现了大于或等于8的数就仍看作是十进制整数；</li>
<li>十六进制整数：使用0x前缀；</li>
<li>浮点数：带小数点的数就是浮点数，整数部分和小数部分为0的话都可以省略不写，科学计数法也是支持的。</li>
</ul>
<p>避免直接比较小数是否相等，因为IEEE754的浮点数不能表示所有的小数。</p>
<p>Number类型可表示的值的范围存储在<code>Number.MAX_VALUE</code>和<code>Number.MIN_VALUE</code>中，如果计算的结果超过了这个表示范围，结果会存储为无穷值（Infinity）。</p>
<p>无穷值分为正无穷（Infinity）和负无穷（-Infinity），要判断一个值是不是无穷值，使用<code>isFinite()</code>函数，返回false表示它为无穷值，返回true表示它还在表示范围之内。</p>
<p>此外还有一个特殊的数值NaN：</p>
<ul>
<li>使用0值除以0值得到的是NaN，而使用其他数值除以0值得到的是无穷值；</li>
<li>NaN参与运算得到的结果也是NaN；</li>
<li>NaN不与包括它自身在内的任何值相等，要判断一个值是不是NaN，使用<code>isNaN()</code>函数，除了NaN值本身外，任何不能转换为数值的值都会使它返回true。</li>
</ul>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>字符串可以以单引号、双引号、反引号包含。</p>
<p>字符串中可以使用转义字符：</p>
<ul>
<li><code>\n</code> ：换行。</li>
<li><code>\t</code> ：制表。</li>
<li><code>\b</code> ：退格。</li>
<li><code>\r</code> ：回车。</li>
<li><code>\f</code> ：换页。</li>
<li><code>\\</code> ：反斜杠。</li>
<li><code>\&#39;</code> ：单引号。</li>
<li><code>\&quot;</code> ：双引号。</li>
<li>\` ：反引号。</li>
<li><code>\xnn</code> ：以十六进制编码的字符。</li>
<li><code>\unnnn</code> ：以十六进制编码的Unicode字符。</li>
</ul>
<p>注意：</p>
<ul>
<li>字符串是不可变的类型。</li>
<li>其他值转换为字符串需要用<code>toString()</code>方法，一般不需要传参，只有在对整数调用时，希望获得整数的非十进制字符串表示，才需要传入一个底数作为参数。</li>
<li>字符串的<code>toString()</code>方法返回自己的一个副本。</li>
<li>null和undefined没有<code>toString()</code>方法，但可以使用<code>String()</code>转型函数，它的规则是：<ul>
<li>如果值有<code>toString()</code>方法，就调用它的该方法；</li>
<li>如果值为null，就返回<code>&quot;null&quot;</code>；</li>
<li>如果值为undefined，就返回<code>&quot;undefined&quot;</code>。</li>
</ul>
</li>
</ul>
<p>模板字面量：<br>    - 使用反引号表示；<br>    - 保留字符串中的换行，可以跨行定义；<br>    - 支持插值语法，使用<code>$&#123;内容&#125;</code>的格式进行字符串内插值，插值的内容可以是任意JS表达式，并最终会将运算结果使用<code>String()</code>转型函数转换为字符串拼接进字符串。</p>
<p>模板字符串的插值语法支持标签函数，标签函数看起来只是一个普通的函数，但它可以接收到模板字符串形成的参数，通过返回的字符串来定义模板字符串最终形成的结果字符串，实现自定义行为，使用时只需要把标签函数作为模板字符串的修饰符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x2Tag</span>(<span class="hljs-params">strings, ...expressions</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(strings); <span class="hljs-comment">// [&#x27;&#x27;, &#x27; + &#x27;, &#x27; = &#x27;, &#x27;&#x27;]</span><br>    <span class="hljs-built_in">console</span>.log(expressions); <span class="hljs-comment">// [1, 2, 3]</span><br>    <span class="hljs-keyword">let</span> e = expressions.map(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val*<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">let</span> r = strings[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;e.length; ++i) &#123;<br>        r += e[i] + strings[i+<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-keyword">let</span> s = x2Tag<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-number">1</span>&#125;</span> + <span class="hljs-subst">$&#123;<span class="hljs-number">2</span>&#125;</span> = <span class="hljs-subst">$&#123;<span class="hljs-number">1</span>+<span class="hljs-number">2</span>&#125;</span>`</span>;<br><span class="hljs-built_in">console</span>.log(s); <span class="hljs-comment">// 2 + 4 = 6</span><br></code></pre></td></tr></table></figure>

<p>模板字符串还支持原始字符串，实际上就是使用了内置的标签函数，使得各种转义字符不进行转义，保持它原始的样子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">`\n\t\u00A9`</span>;<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">String</span>.raw<span class="hljs-string">`\n\t\u00A9`</span>;<br><span class="hljs-built_in">console</span>.log(s1); <span class="hljs-comment">// (换行符)(制表符)©</span><br><span class="hljs-built_in">console</span>.log(s2); <span class="hljs-comment">// \n\t\u00A9</span><br></code></pre></td></tr></table></figure>

<h3 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h3><p>符号是原始值，且<strong>符号实例是唯一、不可变的</strong>。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</p>
<p>使用符号通过调用<code>Symbol()</code>函数来创建一个新符号，这个符号就是独一无二的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sym = <span class="hljs-built_in">Symbol</span>();<br></code></pre></td></tr></table></figure>

<p><code>Symbol()</code>函数<strong>不能当作构造函数通过new来调用</strong>，因为符号类型是一个原始值，通过new就创建成了对象，这与初衷不符。如果你确实想用对象来包装符号，可以使用<code>Object()</code>转型函数。</p>
<p>在创建符号时可以传入一个字符串作为参数，但是这个字符串对符号本身没有任何作用，只能作为调试参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sym1 = <span class="hljs-built_in">Symbol</span>();<br><span class="hljs-keyword">let</span> sym2 = <span class="hljs-built_in">Symbol</span>();<br><span class="hljs-keyword">let</span> sym3 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;sym&quot;</span>);<br><span class="hljs-keyword">let</span> sym4 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;sym&quot;</span>);<br><span class="hljs-built_in">console</span>.log(sym1 === sym2); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(sym3 === sym4); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>可以看到传入的字符串对符号没什么影响，字符串一样的符号照样不会有关联，每次调用<code>Symbol()</code>返回的必定是不同的、独一无二的符号。</p>
<p>符号全局注册表：</p>
<p>为了更好地管理和重用符号，可以使用全局符号注册表，将符号注册到注册表。</p>
<p>注册通过<code>Symbol.for()</code>静态函数进行，它需要一个字符串作为键，如果该键已存在，说明已注册该符号，就返回已存在的该键对应的符号，如果键不存在，就创建一个新符号并在全局注册表中注册该符号，同时我们可以使用<code>Symbol.keyFor()</code>静态方法查询某个符号在注册表中对应的键：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> aSym1 = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&quot;a&quot;</span>);<br><span class="hljs-keyword">let</span> aSym2 = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&quot;a&quot;</span>);<br><span class="hljs-keyword">let</span> bSym = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-built_in">console</span>.log(aSym1 === aSym2); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(aSym1 === bSym); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>.keyFor(aSym1)); <span class="hljs-comment">// a</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>.keyFor(aSym2)); <span class="hljs-comment">// a</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>.keyFor(bSym)); <span class="hljs-comment">// b</span><br></code></pre></td></tr></table></figure>

<p>符号的主要用途就是作为对象属性的键，在使用符号作为字面量对象的属性名时只能用计算属性语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> aSym = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;a&quot;</span>);<br><span class="hljs-keyword">let</span> bSym = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-keyword">let</span> obj = &#123;<br>    [aSym]: <span class="hljs-string">&quot;a val&quot;</span>,<br>    [bSym]: <span class="hljs-string">&quot;b val&quot;</span>,<br>    <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;aaa&quot;</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-string">&quot;bbb&quot;</span><br>&#125;;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj)); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertySymbols(obj)); <span class="hljs-comment">// [Symbol(a), Symbol(b)]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(obj)); <span class="hljs-comment">// &#123;a: &#123;…&#125;, b: &#123;…&#125;, Symbol(a): &#123;…&#125;, Symbol(b): &#123;…&#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p>类似于<code>Object.getOwnPropertyNames()</code>方法只能返回对象的普通属性，<code>Object.getOwnPropertySymbols()</code>是专为符号属性准备的，将返回所有的符号属性构成的数值，此外还有<code>Object.getOwnPropertyDescriptors()</code>则会返回两种属性都包含的描述对象。注意前两者是返回的数组，最后一个返回对象各个属性的描述对象（含四个属性配置项）构成的对象。</p>
<p>常用内置符号：</p>
<ul>
<li><code>Symbol.asyncIterator</code></li>
<li><code>Symbol.hasInstance</code></li>
<li><code>Symbol.isConcatSpreadable</code></li>
<li><code>Symbol.iterator</code></li>
<li><code>Symbol.match</code></li>
<li><code>Symbol.replace</code></li>
<li><code>Symbol.search</code></li>
<li><code>Symbol.species</code></li>
<li><code>Symbol.split</code></li>
<li><code>Symbol.toPrimitive</code></li>
<li><code>Symbol.toStringTag</code></li>
<li><code>Symbol.unscopables</code></li>
</ul>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p>有三个函数可以将非数值类型转换为数值类型，分别是<code>Number()</code>、<code>parseInt()</code>和<code>parseFloat()</code>。</p>
<p><code>Number()</code>可以用于任何类型，后两个用于字符串转数值。</p>
<p><code>Number()</code>的转换规则：</p>
<ul>
<li>数值：直接返回。</li>
<li>布尔值：true转换为1，false转换为0。</li>
<li>null：转换为0。</li>
<li>undefined：转换为NaN。</li>
<li>字符串：按照以下规则转换：<ul>
<li>如果收到的字符串是一个完美的数值字面量表示，就把它转换为对应的数值，要求最多在字符串前后含有若干空白字符，此外不能含有任何不合法的字符。</li>
<li>如果收到的是空字符串，转换为0。</li>
<li>如果是其他任何情况，都返回NaN。</li>
</ul>
</li>
<li>对象：先调用对象的<code>valueOf()</code>方法，尝试将获得的值应用上述规则转换为数值，如果得到的是NaN，就再调用它的<code>toString()</code>方法按照字符串的规则重新转换，返回转换的结果。</li>
</ul>
<p>而<code>parseInt()</code>和<code>parseFloat()</code>是由字符串转换为数值，规则就不一样了，它会尽可能返回一个数值：</p>
<ul>
<li>会忽略开头的空白符，从遇到的第一个非空白字符开始转换。</li>
<li>如果遇到的第一个非空白字符不是数字，直接返回NaN。</li>
<li>对于合法的数值字面量字符进行转换，当遇到了第一个不合法的字符，转换终止，但已转换的部分会保留下来，返回已转换的部分。</li>
<li><code>parseInt()</code>可以按照某个进制来解析整数，通过第二个参数来传递底数，如想把字符串中的数值当作n进制数，就在第二个参数中传入n，返回的始终是十进制的整数，没有第二个参数就会按照解析到的数值字面量来决定（十进制或十六进制，不支持八进制字面量）。</li>
<li><code>parseFloat()</code>则不能指定底数，它只能解析十进制数，在能返回整数的情况下它不会返回小数。</li>
<li>对于空字符串返回NaN。</li>
</ul>
<h2 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h2><p>复杂数据类型（引用类型）只有Object一种，是一个<strong>无序键值对的集合</strong>。</p>
<h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><p>Object类型是一组数据（属性）和功能（方法）的集合。</p>
<p>可以通过创建Object类型的实例来创建自己的对象，然后再给对象添加属性和方法。创建对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br></code></pre></td></tr></table></figure>

<p>或者在没有参数时省略括号：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// 合法，但不推荐</span><br></code></pre></td></tr></table></figure>

<p>Object上的方法有：</p>
<ul>
<li><code>constructor()</code>：用于创建当前对象的函数。</li>
<li><code>hasOwnProperty()</code>：用于判断当前对象实例上是否存在给定的属性。</li>
<li><code>isPrototypeOf()</code>：用于判断当前对象是否为另一个对象的原型。</li>
<li><code>propertyIsEnumerable()</code>：用于判断给定的属性是否可以使用for-in语句枚举。</li>
<li><code>toLocaleString()</code>：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</li>
<li><code>toString()</code>：返回对象的字符串表示。</li>
<li><code>valueOf()</code>：返回对象对应的字符串、数值或布尔值表示。通常与<code>toString()</code>的返回值相同。</li>
</ul>
<p>由于Object是所有对象的基类，因此所有对象都会有这些方法。</p>
<p>关于对象的更多内容，见“面向对象”章节。</p>
<h2 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h2><p>typeof操作符用来确定一个值的类型，对一个名称或值使用该操作符会返回以下字符串之一：</p>
<ul>
<li><code>&quot;undefined&quot;</code></li>
<li><code>&quot;boolean&quot;</code></li>
<li><code>&quot;string&quot;</code></li>
<li><code>&quot;number&quot;</code></li>
<li><code>&quot;symbol&quot;</code></li>
<li><code>&quot;bigint&quot;</code></li>
<li><code>&quot;object&quot;</code></li>
<li><code>&quot;function&quot;</code></li>
</ul>
<p>注意：typeof操作符对null返回<code>&quot;object&quot;</code>，因为null值被认为是一个类似于C语言中空指针的东西。</p>
<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><h2 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h2><p>一元操作符包含自增自减操作符和一元加减操作符。</p>
<p>自增自减操作符与C语言中的自增自减操作符的行为完全相同，但对于非数值类型会进行隐式转换为数值之后再自增自减操作。</p>
<p>一元加减（正负）操作符作用于一个值时，如果它是数值，则直接生效，如果它是其他值，则进行隐式类型转换之后再运算。</p>
<p>也就是自增自减操作符和一元加减操作符返回的<strong>永远是个数值类型的结果</strong>。</p>
<p>隐式类型转换都是使用转型函数来进行的，即<code>Number()</code>。</p>
<h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>ECMAScript中的所有数值都以IEEE 754 64位格式存储，但位操作并不直接应用到64位表示，而是先把值转换为32位整数，再进行位操作，之后再把结果转换为64位。对开发者而言，就好像只有32位整数一样，因为64位整数存储格式是不可见的。</p>
<p>当负数被以二进制字符串输出时，输出的并不是完全的在内存中的表示方式（补码），而是保留了负号的二进制原码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = -<span class="hljs-number">18</span>;<br><span class="hljs-built_in">console</span>.log(num.toString(<span class="hljs-number">2</span>)); <span class="hljs-comment">// &quot;-10010&quot;</span><br></code></pre></td></tr></table></figure>

<p>特殊值NaN和Infinity在位操作中都会被当成0处理。</p>
<p>同样的，位操作符对非数值使用时也会进行隐式类型转换转为数值类型。</p>
<h3 id="按位与或非"><a href="#按位与或非" class="headerlink" title="按位与或非"></a>按位与或非</h3><p>和号(&amp;)来表示按位与，管道符(|)来表示按位或，它们的计算过程都包含了符号位。</p>
<p>波浪符(~)来表示按位非，返回数值每一位取反后的结果（包括符号位）。因此在宏观上，看起来就是对数值取相反数再减一，如25按位非得到的就是-26。</p>
<h3 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或"></a>按位异或</h3><p>相同的二进制位运算得到0，相异得到1。</p>
<h3 id="左移和右移"><a href="#左移和右移" class="headerlink" title="左移和右移"></a>左移和右移</h3><p>左移(&lt;&lt;)会将全部的二进制位（包含符号位）向左移动，末尾补零。</p>
<p>右移分为有符号右移(&gt;&gt;)和无符号右移(&gt;&gt;&gt;)，区别是有符号右移会使用符号位填补左侧空位，无符号右移始终使用0填补。</p>
<h2 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h2><p>逻辑非(!)、逻辑与(&amp;&amp;)、逻辑或(||)。</p>
<p>逻辑非先将值转换为布尔值，再取反。逻辑非始终得到的是布尔值。同时使用两个感叹号，可以实现将任意值转换为布尔值。</p>
<p>由于短路逻辑的存在，逻辑与和逻辑或并不一定会返回布尔值。</p>
<p>短路逻辑：</p>
<ul>
<li>逻辑与：如果第一个操作数解释为“假”值，那么直接返回第一个操作数，否则返回第二个操作数。</li>
<li>逻辑或：如果第一个操作数解释为“真”值，那么直接返回第一个操作数，否则返回第二个操作数。</li>
</ul>
<p>当第二个操作数被短路时，则根本不会对它运行求值。</p>
<h2 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h2><h3 id="乘法操作符"><a href="#乘法操作符" class="headerlink" title="乘法操作符"></a>乘法操作符</h3><p>操作数会被隐式类型转换为数值，对特殊值有以下处理：</p>
<ul>
<li>如果乘积超出了表示范围，会返回±Infinity；</li>
<li>有NaN参与运算，结果也是NaN；</li>
<li>Infinity乘以0的结果是NaN，乘以其他数值的结果是Infinity，但正负号根据两操作数的正负决定。</li>
</ul>
<p>有以下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span>*<span class="hljs-number">2</span>); <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">Infinity</span>*<span class="hljs-number">0</span>); <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">Infinity</span>*<span class="hljs-number">2</span>); <span class="hljs-comment">// Infinity</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">Infinity</span>*-<span class="hljs-number">2</span>); <span class="hljs-comment">// -Infinity</span><br><span class="hljs-built_in">console</span>.log(-<span class="hljs-literal">Infinity</span>*<span class="hljs-number">2</span>); <span class="hljs-comment">// -Infinity</span><br><span class="hljs-built_in">console</span>.log(-<span class="hljs-literal">Infinity</span>*-<span class="hljs-number">2</span>); <span class="hljs-comment">// Infinity</span><br><span class="hljs-built_in">console</span>.log(-<span class="hljs-literal">Infinity</span>*<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// -Infinity</span><br><span class="hljs-built_in">console</span>.log(-<span class="hljs-literal">Infinity</span>*-<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// Infinity</span><br></code></pre></td></tr></table></figure>

<h3 id="除法操作符"><a href="#除法操作符" class="headerlink" title="除法操作符"></a>除法操作符</h3><p>操作数会被隐式类型转换为数值，对特殊值有以下处理：</p>
<ul>
<li>如果乘积超出了表示范围，会返回±Infinity；</li>
<li>有NaN参与运算，结果也是NaN；</li>
<li>Infinity除以Infinity和0除以0的结果都是NaN；</li>
<li>非0数值除以0，根据两操作数的符号返回±Infinity；</li>
<li>Infinity除以非Infinity的任何数值，根据两操作数的符号返回±Infinity。</li>
</ul>
<p>有以下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span>/<span class="hljs-number">2</span>); <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">Infinity</span>/<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span>/<span class="hljs-number">0</span>); <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>); <span class="hljs-comment">// Infinity</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>/-<span class="hljs-number">0</span>); <span class="hljs-comment">// -Infinity</span><br><span class="hljs-built_in">console</span>.log(-<span class="hljs-number">3</span>/<span class="hljs-number">0</span>); <span class="hljs-comment">// -Infinity</span><br><span class="hljs-built_in">console</span>.log(-<span class="hljs-number">4</span>/-<span class="hljs-number">0</span>); <span class="hljs-comment">// Infinity</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">Infinity</span>/<span class="hljs-number">0</span>); <span class="hljs-comment">// Infinity</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">Infinity</span>/-<span class="hljs-number">1</span>); <span class="hljs-comment">// -Infinity</span><br><span class="hljs-built_in">console</span>.log(-<span class="hljs-literal">Infinity</span>/<span class="hljs-number">2</span>); <span class="hljs-comment">// -Infinity</span><br><span class="hljs-built_in">console</span>.log(-<span class="hljs-literal">Infinity</span>/-<span class="hljs-number">3</span>); <span class="hljs-comment">// Infinity</span><br></code></pre></td></tr></table></figure>

<h3 id="取模操作符"><a href="#取模操作符" class="headerlink" title="取模操作符"></a>取模操作符</h3><p>操作数会被隐式类型转换为数值，对特殊值有以下处理：</p>
<ul>
<li>如果被除数是Infinity，除数是有限值，则返回NaN。</li>
<li>如果被除数是有限值，除数是0，则返回NaN。</li>
<li>如果是Infinity除以Infinity，则返回NaN。</li>
<li>如果被除数是有限值，除数是Infinity，则返回被除数。</li>
<li>如果被除数是0，除数不是0，则返回0。</li>
</ul>
<h3 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h3><p>指数操作符使用两个乘号表示，是ES7新增的内容，等同于<code>Math.pow()</code>的功能，同样会进行操作数的隐式类型转换。</p>
<p>同时也有自己的指数赋值操作符(**=)。</p>
<h3 id="加法操作符"><a href="#加法操作符" class="headerlink" title="加法操作符"></a>加法操作符</h3><p>和前面的操作符不同，它<strong>返回的不一定是数值</strong>：</p>
<ul>
<li>如果两个操作数中没有字符串，则将两个操作数都隐式转换为数值再进行数值的运算；</li>
<li>如果两个操作数中有字符串，则会将两个操作数都隐式转换为字符串然后进行字符串的拼接操作。</li>
</ul>
<p>对于两个数值的运算：</p>
<ul>
<li>如果有任一操作数是NaN，则返回NaN；</li>
<li>如果是Infinity加Infinity，则返回Infinity；</li>
<li>如果是-Infinity加-Infinity，则返回-Infinity；</li>
<li>如果是Infinity加-Infinity，则返回NaN；</li>
<li>如果是+0加+0，则返回+0；</li>
<li>如果是-0加+0，则返回+0；</li>
<li>如果是-0加-0，则返回-0。</li>
</ul>
<h3 id="减法运算符"><a href="#减法运算符" class="headerlink" title="减法运算符"></a>减法运算符</h3><p>减法的各种行为都如同把第二个操作数取相反数再和第一个数相加一样，因此可类比加法的规则，但是唯一的不同是加法中有一操作数为字符串则结果是字符串的拼接，而减法始终会把两个操作数隐式转换为数值进行运算。</p>
<h2 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h2><h3 id="大小比较"><a href="#大小比较" class="headerlink" title="大小比较"></a>大小比较</h3><p>包括小于、大于、小于等于和大于等于四个关系运算符，它们总是返回布尔值，比较时进行隐式类型转换的规则为：</p>
<ul>
<li>如果两个操作数都是数值，那么直接比较大小（涉及到NaN的比较都会直接返回false）；</li>
<li>如果两个操作数都是字符串，那么比较两个操作数的字典序（以ASCII大小为依据）；</li>
<li>如果其中一个操作数为数值，则将另一操作数转为数值进行比较；</li>
<li>布尔值始终转换为数值参与比较；</li>
<li>对象作为操作数将调用其valueOf方法使用取得的值进行比较，如果valueOf得不到合适的值将调用其toString方法参与比较。</li>
</ul>
<h3 id="相等比较"><a href="#相等比较" class="headerlink" title="相等比较"></a>相等比较</h3><p>相等比较的操作符分为两组，分别为相等(==)和不等(!=)、全等(===)和不全等(!==)。</p>
<p>区别在于相等和不等会在比较时进行类型转换，全等和不全等必须比较同类型的值，类型不同的值直接会判定为不等。</p>
<p>相等和不等判断时的规则为：</p>
<ul>
<li>有NaN参与比较，相等操作符直接返回false，不等操作符直接返回true，两个NaN比较也是如此；</li>
<li>null与undefined判断为相等；</li>
<li>布尔值将转换为数值来参与比较；</li>
<li>字符串和数值比较时，将字符串转为数值再比较；</li>
<li>两个对象比较则判断它们是不是同一个对象，如果是同一个对象的引用则相等，否则不等；</li>
<li>如果只有一个操作数是对象，那么调用它的<code>valueOf()</code>方法用取得的值进行比较。</li>
</ul>
<h2 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h2><p>赋值包括简单赋值操作符(=)和复合赋值操作符(*=、/=、%=、+=、-=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=)。</p>
<h2 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h2><p>条件操作符的行为与C语言的三元条件运算符的行为完全一致。</p>
<h2 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h2><p>逗号操作符的行为与C语言的逗号运算符的行为完全一致，可以将多个表达式放在一个语句中执行，最终整个逗号表达式的值是最后一个子表达式的值。</p>
<h1 id="语句-1"><a href="#语句-1" class="headerlink" title="语句"></a>语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>if语句接受一个表达式，并将其进行隐式类型转换，得到一个布尔值，根据布尔值的真假决定是否执行后面的代码块。</p>
<p>可以使用if-else、if-else if-else构成分支语句。</p>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>switch语句类似于C语言中的switch语句，但是不同的是JS增强了它。</p>
<p>JS的switch语句可以使用任何类型的变量作判断，同时case的值也可以使用任意的变量和表达式，而不需要一定是常量。switch语句在判断变量和每个case时使用的是全等操作符比较。</p>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>与C语言中的while循环的表现完全一致，先判断后循环，最少循环零次。</p>
<h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h2><p>与C语言中的do-while循环的表现完全一致，先循环后判断，至少循环一次。</p>
<h2 id="三种for循环"><a href="#三种for循环" class="headerlink" title="三种for循环"></a>三种for循环</h2><h3 id="传统for循环"><a href="#传统for循环" class="headerlink" title="传统for循环"></a>传统for循环</h3><p>传统for循环语句与C语言中的for循环的表现类似，需要提供初始化语句、判断表达式和状态转移表达式，且三者都可以省略。</p>
<h3 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h3><p>for-in语句<strong>用于枚举对象中的非符号键属性</strong>。</p>
<p>ECMAScript中对象的属性是无序的，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。</p>
<p>如果for-in循环要迭代的变量是null或undefined，则不执行循环体。</p>
<h3 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for-of循环"></a>for-of循环</h3><p>for-of循环<strong>用于遍历可迭代对象的元素</strong>。</p>
<p>for-of循环会按照可迭代对象返回的默认迭代器的<code>next()</code>方法产生值的顺序迭代元素。具体见后续迭代器与生成器的章节。</p>
<p>如果尝试迭代的变量不支持迭代，则for-of语句会抛出错误。</p>
<p>ES9对for-of语句进行了扩展，增加了for-await-of循环，以支持生成期约的异步可迭代对象。</p>
<h2 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h2><p>标签语句的格式是使用一个名称加一个冒号标记某一语句，后面可通过continue和break语句引用。</p>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p>流程控制语句包括break语句和continue语句，主要用来控制循环的流程。</p>
<p>它们的行为与C语言中类似，唯一不同的是它们可以使用标签，从而<strong>一次性跳出多层嵌套的循环</strong>，有以下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">aloop:<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    <span class="hljs-attr">bloop</span>:<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// j&gt;1时，直接break最外层循环，循环结束</span><br>            <span class="hljs-keyword">break</span> aloop;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; k++) &#123;<br>            <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// k&gt;1时，结束第三层循环，continue到第二层继续</span><br>                <span class="hljs-keyword">continue</span> bloop;<br>            &#125;<br>            <span class="hljs-built_in">console</span>.log(i, j, k);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h2><p>with语句将某个变量作为执行的上下文，当使用一个名称时，首先会判断这个名称是否是块内的局部变量，如果不是，则向外层的with作用域中找，即查找with指定的对象上是否有该属性，如果有，就使用该属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj&quot;</span>, <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;aaa&quot;</span> &#125;;<br><span class="hljs-function"><span class="hljs-title">with</span>(<span class="hljs-params">obj</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> aaa = a;<br>    <span class="hljs-built_in">console</span>.log(aaa); <span class="hljs-comment">// aaa</span><br>    <span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// obj</span><br>    name = <span class="hljs-string">&quot;ooo&quot;</span>;<br>    <span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// ooo</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>严格模式下不能使用with语句，否则会抛出错误。因为with语句影响性能且难以调试其中的代码。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>ECMAScript中的函数使用function关键字声明，后跟一组参数，然后是函数体。</p>
<p>ECMAScript中的函数不需要指定是否返回值。任何函数在任何时间都可以使用return语句来返回函数的值。</p>
<p>return语句也可以不带返回值，这时函数会立即停止执行并返回undefined。</p>
<p>严格模式对函数的限制：</p>
<ul>
<li>函数不能以eval或arguments作为名称；</li>
<li>函数的参数不能叫eval或arguments；</li>
<li>两个命名参数不能拥有同一个名称。</li>
</ul>
<p>更多关于函数的内容见后面章节。</p>

      </section>
      <section class="extra">
        <!-- 
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>Dasen Sun</li>
    <li><strong>本文链接：</strong><a href="http://example.com/2021/12/04/js001/index.html" title="http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;12&#x2F;04&#x2F;js001&#x2F;index.html">http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;12&#x2F;04&#x2F;js001&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
         -->
        
          <br>
          <center><hr></center>
          <br>
          <center>* 你好，我是大森。如果文章内容帮到了你，你可通过下方付款二维码支持作者 *</center>
          <br>
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="/images/qrcode/alipay.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
          <center><hr></center>
          <br>
        
        
        
  <nav class="nav">
    <a href="/2021/12/07/js002/"><i class="iconfont iconleft"></i><i class="iconfont iconleft"></i> JavaScript学习笔记（2）：值、作用域与内存</a>
    <a href="/2021/11/22/frontend-css-006/">CSS：深入盒模型 <i class="iconfont iconright"></i><i class="iconfont iconright"></i></a>
  </nav>

      </section>
      <!--  -->
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-text">注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-text">严格模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-text">语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-text">关键字和保留字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#var%E5%A3%B0%E6%98%8E"><span class="toc-text">var声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let%E5%A3%B0%E6%98%8E"><span class="toc-text">let声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E5%A3%B0%E6%98%8E"><span class="toc-text">const声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%A3%B0%E6%98%8E"><span class="toc-text">无声明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">简单数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Undefined%E7%B1%BB%E5%9E%8B"><span class="toc-text">Undefined类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Null%E7%B1%BB%E5%9E%8B"><span class="toc-text">Null类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boolean%E7%B1%BB%E5%9E%8B"><span class="toc-text">Boolean类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Number%E7%B1%BB%E5%9E%8B"><span class="toc-text">Number类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E5%9E%8B"><span class="toc-text">String类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol%E7%B1%BB%E5%9E%8B"><span class="toc-text">Symbol类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="toc-text">数值转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">复杂数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB%E5%9E%8B"><span class="toc-text">Object类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">typeof操作符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">一元操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">位操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E4%B8%8E%E6%88%96%E9%9D%9E"><span class="toc-text">按位与或非</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96"><span class="toc-text">按位异或</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E5%92%8C%E5%8F%B3%E7%A7%BB"><span class="toc-text">左移和右移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">布尔操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">算术操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">乘法操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">除法操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%A8%A1%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">取模操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">指数操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">加法操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">减法运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">关系操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83"><span class="toc-text">大小比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83"><span class="toc-text">相等比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">赋值操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">条件操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">逗号操作符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5-1"><span class="toc-text">语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="toc-text">if语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="toc-text">switch语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="toc-text">while循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do-while%E5%BE%AA%E7%8E%AF"><span class="toc-text">do-while循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8Dfor%E5%BE%AA%E7%8E%AF"><span class="toc-text">三种for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9Ffor%E5%BE%AA%E7%8E%AF"><span class="toc-text">传统for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-in%E5%BE%AA%E7%8E%AF"><span class="toc-text">for-in循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-of%E5%BE%AA%E7%8E%AF"><span class="toc-text">for-of循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E8%AF%AD%E5%8F%A5"><span class="toc-text">标签语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">流程控制语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#with%E8%AF%AD%E5%8F%A5"><span class="toc-text">with语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="https://www.instagram.com/zhangsiyu_2/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/sadose/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:sadose@qq.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  孙大森 - 2021</p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>